<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>EdTech Canvas Pro</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, setDoc, onSnapshot, collection, getDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        const firebaseConfig = {
            apiKey: "AIzaSyD2UPzm5FauzRDMUi_iv-5PQDG391xL_Eo",
            authDomain: "minnnano-no-to.firebaseapp.com",
            projectId: "minnnano-no-to",
            storageBucket: "minnnano-no-to.firebasestorage.app",
            messagingSenderId: "589337230554",
            appId: "1:589337230554:web:6c564cb5bbe08573ceb9e3"
        };

        let app, auth, db;
        try {
            app = initializeApp(firebaseConfig);
            auth = getAuth(app);
            db = getFirestore(app);
        } catch (e) {
            console.error("Firebase初期化失敗", e);
        }

        let state = {
            user: null,
            role: 'student',
            viewMode: 'mine', 
            userName: '',
            currentTask: "課題を待っています...",
            isPublic: false,
            isDrawing: false,
            brushColor: '#000000',
            brushSize: 3,
            bgImage: null,
            editingStudentId: null,
            isTaskCreating: false,
            floatingImages: [],
            selectedImageIdx: -1,
            isResizing: false,
            isDraggingImage: false
        };

        const canvas = document.getElementById('drawing-canvas');
        const feedbackCanvas = document.getElementById('feedback-canvas');
        const taskCreateCanvas = document.getElementById('task-create-canvas');

        window.onload = async () => {
            checkUrlParams();
            
            if (state.role === 'student' && !state.userName) {
                const savedName = localStorage.getItem('school_note_user_name');
                const name = prompt("あなたのなまえを入力してください", savedName || "");
                state.userName = name || "ゲスト_" + Math.floor(Math.random() * 1000);
                localStorage.setItem('school_note_user_name', state.userName);
            }

            setTimeout(setupMainCanvas, 100);
            window.addEventListener('resize', setupMainCanvas);
            
            updateUI();
            setupEventListeners(canvas); 
            setupEventListeners(feedbackCanvas);
            setupTaskCreateListeners(taskCreateCanvas);

            document.addEventListener('paste', handlePaste);

            if (!auth) return;
            try {
                await signInAnonymously(auth);
                onAuthStateChanged(auth, (user) => {
                    if (user) {
                        state.user = user;
                        initSync();
                        updateUI();
                    }
                });
            } catch (error) {
                console.error("Login Error:", error.code);
            }
        };

        function handlePaste(e) {
            if (!state.isTaskCreating) return;
            const items = (e.clipboardData || e.originalEvent.clipboardData).items;
            for (let item of items) {
                if (item.type.indexOf("image") !== -1) {
                    const blob = item.getAsFile();
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        const img = new Image();
                        img.onload = () => {
                            state.floatingImages.push({
                                img: img,
                                x: 50,
                                y: 50,
                                w: img.width > 400 ? 400 : img.width,
                                h: img.width > 400 ? (img.height * (400 / img.width)) : img.height
                            });
                            drawTaskCreateCanvas();
                        };
                        img.src = event.target.result;
                    };
                    reader.readAsDataURL(blob);
                }
            }
        }

        function initSync() {
            if (!db) return;
            const settingsRef = doc(db, 'class-settings', 'current');
            onSnapshot(settingsRef, (snap) => {
                if (snap.exists()) {
                    const data = snap.data();
                    state.currentTask = data.taskTitle || "課題を待っています...";
                    state.bgImage = data.bgImage || null;
                    state.isPublic = data.isPublic || false;
                    if (state.role === 'student' && !state.isPublic) state.viewMode = 'mine';
                    applyBg();
                    updateUI();
                }
            });

            if (state.role === 'student' && state.user) {
                onSnapshot(doc(db, 'student-canvas', state.user.uid), (snap) => {
                    if (snap.exists()) {
                        const data = snap.data();
                        if (data.feedbackData) renderFeedback(data.feedbackData);
                    }
                });
            }

            onSnapshot(collection(db, 'student-canvas'), (snap) => {
                const list = [];
                snap.forEach(doc => list.push(doc.data()));
                renderSubmissionsGrid(list);
            });
        }

        function renderFeedback(dataUrl) {
            const img = new Image();
            img.onload = () => {
                const feedbackLayer = document.getElementById('feedback-layer');
                if (feedbackLayer) {
                    const fctxL = feedbackLayer.getContext('2d');
                    fctxL.clearRect(0, 0, feedbackLayer.width, feedbackLayer.height);
                    fctxL.drawImage(img, 0, 0, feedbackLayer.width, feedbackLayer.height);
                }
            };
            img.src = dataUrl;
        }

        async function syncCanvas() {
            if (state.role === 'student' && state.user && db) {
                const dataUrl = canvas.toDataURL('image/webp', 0.5);
                await setDoc(doc(db, 'student-canvas', state.user.uid), {
                    uid: state.user.uid,
                    name: state.userName,
                    canvasData: dataUrl,
                    lastUpdate: Date.now()
                }, { merge: true });
            }
            if (state.role === 'teacher' && state.editingStudentId && db) {
                const feedbackDataUrl = feedbackCanvas.toDataURL('image/webp', 0.5);
                await setDoc(doc(db, 'student-canvas', state.editingStudentId), {
                    feedbackData: feedbackDataUrl,
                    lastUpdate: Date.now()
                }, { merge: true });
            }
        }

        function setupMainCanvas() {
            const container = canvas.parentElement;
            if (!container) return;
            const navH = document.querySelector('nav').offsetHeight;
            const taskH = document.getElementById('task-container').offsetHeight;
            const switchH = (state.role === 'student' && state.isPublic) ? document.getElementById('view-switch').offsetHeight : 0;
            const toolH = document.getElementById('student-tools')?.offsetHeight || 0;
            const teacherToolH = state.role === 'teacher' ? document.getElementById('teacher-view').offsetHeight : 0;
            const windowH = window.innerHeight;
            const availableH = windowH - navH - taskH - switchH - toolH - teacherToolH - 40;
            const rect = container.getBoundingClientRect();
            
            const temp = document.createElement('canvas');
            temp.width = canvas.width;
            temp.height = canvas.height;
            if (canvas.width > 0) temp.getContext('2d').drawImage(canvas, 0, 0);
            
            canvas.width = rect.width;
            canvas.height = availableH;
            const feedbackLayer = document.getElementById('feedback-layer');
            feedbackLayer.width = canvas.width;
            feedbackLayer.height = canvas.height;
            
            if (temp.width > 0) canvas.getContext('2d').drawImage(temp, 0, 0, canvas.width, canvas.height);
            applyBg();
        }

        function setupEventListeners(targetCanvas) {
            const getPos = (e) => {
                const rect = targetCanvas.getBoundingClientRect();
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                return { 
                    x: (clientX - rect.left) * (targetCanvas.width / rect.width), 
                    y: (clientY - rect.top) * (targetCanvas.height / rect.height)
                };
            };
            const start = (e) => {
                if (state.role === 'student' && state.viewMode === 'others') return;
                state.isDrawing = true;
                const tctx = targetCanvas.getContext('2d');
                const pos = getPos(e);
                tctx.beginPath();
                tctx.moveTo(pos.x, pos.y);
            };
            const move = (e) => {
                if (!state.isDrawing) return;
                const tctx = targetCanvas.getContext('2d');
                const pos = getPos(e);
                tctx.strokeStyle = state.brushColor;
                tctx.lineWidth = state.brushSize;
                tctx.lineJoin = 'round';
                tctx.lineCap = 'round';
                tctx.lineTo(pos.x, pos.y);
                tctx.stroke();
            };
            const stop = () => {
                if (state.isDrawing) {
                    state.isDrawing = false;
                    syncCanvas();
                }
            };
            targetCanvas.addEventListener('mousedown', start);
            targetCanvas.addEventListener('mousemove', move);
            window.addEventListener('mouseup', stop);
            targetCanvas.addEventListener('touchstart', (e) => { if (state.role === 'student' && state.viewMode === 'others') return; start(e); }, {passive: false});
            targetCanvas.addEventListener('touchmove', (e) => { if (state.role === 'student' && state.viewMode === 'others') return; e.preventDefault(); move(e); }, {passive: false});
            targetCanvas.addEventListener('touchend', stop);
        }

        function setupTaskCreateListeners(targetCanvas) {
            let lastX, lastY;
            const getPos = (e) => {
                const rect = targetCanvas.getBoundingClientRect();
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                return { 
                    x: (clientX - rect.left) * (targetCanvas.width / rect.width), 
                    y: (clientY - rect.top) * (targetCanvas.height / rect.height)
                };
            };

            const start = (e) => {
                const pos = getPos(e);
                lastX = pos.x; lastY = pos.y;
                state.selectedImageIdx = -1;
                state.isResizing = false;
                state.isDraggingImage = false;

                // 画像の当たり判定
                for (let i = state.floatingImages.length - 1; i >= 0; i--) {
                    const img = state.floatingImages[i];
                    // 右下のハンドル
                    if (pos.x > img.x + img.w - 40 && pos.x < img.x + img.w + 20 &&
                        pos.y > img.y + img.h - 40 && pos.y < img.y + img.h + 20) {
                        state.selectedImageIdx = i;
                        state.isResizing = true;
                        break;
                    }
                    // 画像本体
                    if (pos.x > img.x && pos.x < img.x + img.w && pos.y > img.y && pos.y < img.y + img.h) {
                        state.selectedImageIdx = i;
                        state.isDraggingImage = true;
                        break;
                    }
                }

                if (state.selectedImageIdx === -1) {
                    state.isDrawing = true;
                    const ctx = targetCanvas.getContext('2d');
                    ctx.beginPath();
                    ctx.moveTo(pos.x, pos.y);
                }
                drawTaskCreateCanvas();
            };

            const move = (e) => {
                const pos = getPos(e);
                const dx = pos.x - lastX;
                const dy = pos.y - lastY;

                if (state.selectedImageIdx !== -1) {
                    const img = state.floatingImages[state.selectedImageIdx];
                    if (state.isResizing) {
                        img.w = Math.max(50, img.w + dx);
                        img.h = Math.max(50, img.h + dy);
                    } else if (state.isDraggingImage) {
                        img.x += dx;
                        img.y += dy;
                    }
                    drawTaskCreateCanvas();
                } else if (state.isDrawing) {
                    const ctx = targetCanvas.getContext('2d');
                    ctx.strokeStyle = state.brushColor;
                    ctx.lineWidth = state.brushSize;
                    ctx.lineJoin = 'round';
                    ctx.lineCap = 'round';
                    ctx.lineTo(pos.x, pos.y);
                    ctx.stroke();
                }
                lastX = pos.x; lastY = pos.y;
            };

            const stop = () => {
                state.isDrawing = false;
                state.isResizing = false;
                state.isDraggingImage = false;
            };

            targetCanvas.addEventListener('mousedown', start);
            targetCanvas.addEventListener('mousemove', move);
            window.addEventListener('mouseup', stop);
            targetCanvas.addEventListener('touchstart', (e) => start(e), {passive: false});
            targetCanvas.addEventListener('touchmove', (e) => { e.preventDefault(); move(e); }, {passive: false});
            window.addEventListener('touchend', stop);
        }

        function drawTaskCreateCanvas() {
            const overlay = document.getElementById('task-image-overlay');
            overlay.innerHTML = '';
            state.floatingImages.forEach((imgData, idx) => {
                const imgWrap = document.createElement('div');
                imgWrap.className = `absolute border-2 ${state.selectedImageIdx === idx ? 'border-blue-500 shadow-2xl z-30' : 'border-gray-300 z-20'}`;
                imgWrap.style.left = `${imgData.x}px`;
                imgWrap.style.top = `${imgData.y}px`;
                imgWrap.style.width = `${imgData.w}px`;
                imgWrap.style.height = `${imgData.h}px`;
                imgWrap.style.backgroundImage = `url(${imgData.img.src})`;
                imgWrap.style.backgroundSize = '100% 100%';
                imgWrap.style.opacity = "1";
                imgWrap.style.pointerEvents = 'none'; 

                if (state.selectedImageIdx === idx) {
                    const handle = document.createElement('div');
                    handle.className = "absolute right-[-15px] bottom-[-15px] w-8 h-8 bg-blue-600 rounded-full border-2 border-white flex items-center justify-center shadow-lg pointer-events-none";
                    handle.innerHTML = `<svg width="16" height="16" viewBox="0 0 24 24" fill="white"><path d="M21 15v6h-6M9 3H3v6M21 3l-6 6M3 21l6-6"/></svg>`;
                    imgWrap.appendChild(handle);
                    
                    const del = document.createElement('div');
                    del.className = "absolute left-[-15px] top-[-15px] w-8 h-8 bg-red-600 text-white rounded-full flex items-center justify-center text-[14px] font-bold cursor-pointer pointer-events-auto shadow-md";
                    del.textContent = '×';
                    del.onclick = (e) => {
                        e.stopPropagation();
                        state.floatingImages.splice(idx, 1);
                        state.selectedImageIdx = -1;
                        drawTaskCreateCanvas();
                    };
                    imgWrap.appendChild(del);
                }
                overlay.appendChild(imgWrap);
            });
        }

        window.openTaskCreateModal = () => {
            state.isTaskCreating = true;
            state.floatingImages = [];
            state.selectedImageIdx = -1;
            const modal = document.getElementById('task-create-modal');
            modal.classList.remove('hidden');
            const container = taskCreateCanvas.parentElement;
            const rect = container.getBoundingClientRect();
            taskCreateCanvas.width = rect.width;
            taskCreateCanvas.height = rect.height;
            const ctx = taskCreateCanvas.getContext('2d');
            ctx.clearRect(0, 0, taskCreateCanvas.width, taskCreateCanvas.height);
            document.getElementById('task-title-input').value = "";
            drawTaskCreateCanvas();
        };

        window.closeTaskCreateModal = () => {
            state.isTaskCreating = false;
            document.getElementById('task-create-modal').classList.add('hidden');
        };

        window.handleTaskImageUpload = (e) => {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (event) => {
                const img = new Image();
                img.onload = () => {
                    state.floatingImages.push({
                        img: img,
                        x: 100,
                        y: 100,
                        w: img.width > 400 ? 400 : img.width,
                        h: img.width > 400 ? (img.height * (400 / img.width)) : img.height
                    });
                    drawTaskCreateCanvas();
                };
                img.src = event.target.result;
            };
            reader.readAsDataURL(file);
        };

        window.finalizeAndDistribute = async () => {
            const title = document.getElementById('task-title-input').value || "新しい課題";
            const offscreen = document.createElement('canvas');
            offscreen.width = taskCreateCanvas.width;
            offscreen.height = taskCreateCanvas.height;
            const octx = offscreen.getContext('2d');
            
            octx.fillStyle = "#ffffff";
            octx.fillRect(0, 0, offscreen.width, offscreen.height);
            
            for (let imgData of state.floatingImages) {
                octx.globalAlpha = 1.0;
                octx.drawImage(imgData.img, imgData.x, imgData.y, imgData.w, imgData.h);
            }
            
            octx.globalAlpha = 1.0;
            octx.drawImage(taskCreateCanvas, 0, 0);
            
            const finalDataUrl = offscreen.toDataURL('image/jpeg', 0.9); 

            if (confirm("この内容（画像＋手書き）で全児童に配信しますか？")) {
                await setDoc(doc(db, 'class-settings', 'current'), { 
                    taskTitle: title, 
                    bgImage: finalDataUrl,
                    lastDistribute: Date.now()
                });
                alert("配信しました！");
                closeTaskCreateModal();
            }
        };

        window.openPreviewModal = async (uid, name) => {
            state.editingStudentId = uid;
            const modal = document.getElementById('feedback-modal');
            modal.classList.remove('hidden');
            
            const container = feedbackCanvas.parentElement;
            const rect = container.getBoundingClientRect();
            feedbackCanvas.width = rect.width;
            feedbackCanvas.height = rect.height;

            const snap = await getDoc(doc(db, 'student-canvas', uid));
            if (snap.exists()) {
                const data = snap.data();
                const feedbackTaskBg = document.getElementById('feedback-task-bg');
                if (state.bgImage) {
                    feedbackTaskBg.style.backgroundImage = `url(${state.bgImage})`;
                }
                document.getElementById('feedback-bg').style.backgroundImage = `url(${data.canvasData})`;
                
                const fctx = feedbackCanvas.getContext('2d');
                fctx.clearRect(0, 0, feedbackCanvas.width, feedbackCanvas.height);
                if (data.feedbackData) {
                    const img = new Image();
                    img.onload = () => fctx.drawImage(img, 0, 0, feedbackCanvas.width, feedbackCanvas.height);
                    img.src = data.feedbackData;
                }
            }
        };

        window.closeFeedbackModal = () => {
            state.editingStudentId = null;
            document.getElementById('feedback-modal').classList.add('hidden');
        };

        window.switchView = (mode) => {
            if (mode === 'others' && !state.isPublic && state.role === 'student') return;
            state.viewMode = mode;
            updateUI();
            setTimeout(setupMainCanvas, 50);
        };

        window.togglePublic = async () => {
            const newVal = !state.isPublic;
            await setDoc(doc(db, 'class-settings', 'current'), { isPublic: newVal }, { merge: true });
        };

        window.clearCanvas = (id) => {
            if (confirm("すべて消去しますか？")) {
                const target = document.getElementById(id);
                const tctx = target.getContext('2d');
                tctx.clearRect(0, 0, target.width, target.height);
                if (id === 'task-create-canvas') {
                    state.floatingImages = [];
                    state.selectedImageIdx = -1;
                    drawTaskCreateCanvas();
                } else {
                    syncCanvas();
                }
            }
        };

        function applyBg() {
            const bgs = document.querySelectorAll('.task-bg');
            bgs.forEach(bg => {
                if (state.bgImage) {
                    bg.style.backgroundImage = `url(${state.bgImage})`;
                    bg.style.backgroundSize = 'contain';
                    bg.style.backgroundPosition = 'center';
                    bg.style.backgroundRepeat = 'no-repeat';
                    bg.style.opacity = "1";
                }
            });
        }

        function renderSubmissionsGrid(list) {
            const grid = document.getElementById('submissions-grid');
            if (!grid) return;
            grid.innerHTML = '';
            list.sort((a,b) => b.lastUpdate - a.lastUpdate);
            list.forEach(data => {
                const div = document.createElement('div');
                div.className = "bg-white p-2 border-2 border-gray-200 rounded-lg shadow-sm cursor-pointer hover:border-blue-500 relative h-[180px] overflow-hidden";
                
                const bgImgHtml = state.bgImage ? `<img src="${state.bgImage}" class="absolute inset-0 w-full h-full object-contain z-10 opacity-100">` : '';
                const canvasImgHtml = `<img src="${data.canvasData}" class="absolute inset-0 w-full h-full object-contain z-20 opacity-100">`;
                const feedbackImgHtml = data.feedbackData ? `<img src="${data.feedbackData}" class="absolute inset-0 w-full h-full object-contain z-30 opacity-100">` : '';

                div.innerHTML = `
                    <div class="absolute inset-0 z-[60] bg-transparent"></div>
                    <p class="text-[11px] font-bold truncate text-blue-800 mb-1 relative z-[70] bg-white bg-opacity-80 px-1">${data.name}</p>
                    <div class="relative aspect-[4/3] border bg-white pointer-events-none overflow-hidden h-[130px]">
                        ${bgImgHtml}
                        ${canvasImgHtml}
                        ${feedbackImgHtml}
                    </div>
                `;
                div.addEventListener('click', () => openPreviewModal(data.uid, data.name));
                grid.appendChild(div);
            });
        }

        function updateUI() {
            document.getElementById('task-display').textContent = state.currentTask;
            document.getElementById('role-label').textContent = state.role === 'teacher' ? "先生" : "児童";
            document.getElementById('name-label').textContent = state.userName + " さん";
            const studentView = document.getElementById('student-view');
            const teacherView = document.getElementById('teacher-view');
            const submissionsView = document.getElementById('submissions-view');
            const viewSwitch = document.getElementById('view-switch');
            const publicToggleBtn = document.getElementById('public-toggle-btn');
            if (state.role === 'teacher') {
                teacherView.classList.remove('hidden');
                studentView.classList.add('hidden');
                submissionsView.classList.remove('hidden');
                viewSwitch.classList.add('hidden');
                publicToggleBtn.classList.remove('hidden');
            } else {
                teacherView.classList.add('hidden');
                publicToggleBtn.classList.add('hidden');
                if (state.isPublic) viewSwitch.classList.remove('hidden');
                else { viewSwitch.classList.add('hidden'); state.viewMode = 'mine'; }
                if (state.viewMode === 'mine') { studentView.classList.remove('hidden'); submissionsView.classList.add('hidden'); }
                else { studentView.classList.add('hidden'); submissionsView.classList.remove('hidden'); }
            }
        }

        function checkUrlParams() {
            const p = new URLSearchParams(window.location.search);
            state.role = p.get('role') || 'student';
            if (p.get('name')) state.userName = p.get('name');
        }

        window.setPenColor = (c) => state.brushColor = c;
    </script>
    <style>
        * { -webkit-tap-highlight-color: transparent; box-sizing: border-box; }
        body { touch-action: none; -webkit-user-select: none; user-select: none; overflow: hidden; position: fixed; width: 100%; height: 100%; margin: 0; padding: 0; }
        .canvas-container { position: relative; width: 100%; background: white; z-index: 10; touch-action: none; }
        canvas { display: block; touch-action: none; opacity: 1 !important; }
        #feedback-layer { pointer-events: none; z-index: 20; }
        
        .task-bg, #feedback-task-bg, #feedback-bg { 
            opacity: 1 !important; 
            background-color: white;
        }
        img { opacity: 1 !important; }
    </style>
</head>
<body class="bg-gray-200 flex flex-col font-sans text-gray-900 overflow-hidden">
    <nav class="bg-blue-900 text-white p-3 flex justify-between items-center shadow-lg flex-shrink-0 z-50">
        <h1 class="font-bold text-sm">EdTech Canvas Pro <span id="role-label" class="text-[10px] bg-blue-600 px-2 py-0.5 rounded-full ml-2"></span></h1>
        <div id="name-label" class="text-xs font-medium"></div>
    </nav>

    <div class="p-2 flex-grow flex flex-col overflow-hidden relative">
        <div id="task-container" class="bg-white p-2 rounded-lg shadow mb-2 border-l-8 border-blue-600 flex justify-between items-center flex-shrink-0">
            <h2 id="task-display" class="text-xs font-black truncate text-gray-800 max-w-[70%]"></h2>
            <button id="public-toggle-btn" onclick="togglePublic()" class="hidden px-4 py-1.5 bg-blue-700 text-white rounded-full text-[10px] font-bold shadow-sm">回答を全員公開</button>
        </div>

        <div id="view-switch" class="hidden flex gap-2 mb-2 px-1 flex-shrink-0">
            <button onclick="switchView('mine')" class="flex-1 py-3 rounded-xl font-bold bg-blue-600 text-white shadow-lg text-sm transition-all active:scale-95">自分のノート</button>
            <button onclick="switchView('others')" class="flex-1 py-3 rounded-xl font-bold bg-gray-300 text-gray-600 text-sm transition-all active:scale-95">みんなのノート</button>
        </div>
        
        <div id="student-view" class="flex-grow flex flex-col gap-1 overflow-hidden">
            <div id="student-tools" class="bg-white p-2 rounded-t-xl shadow-md flex gap-4 items-center flex-shrink-0 z-30 border-b">
                <button onclick="setPenColor('#000000')" class="w-9 h-9 rounded-full bg-black border-4 border-gray-100 shadow-sm"></button>
                <button onclick="setPenColor('#ff4444')" class="w-9 h-9 rounded-full bg-red-500 border-4 border-gray-100 shadow-sm"></button>
                <button onclick="setPenColor('#4444ff')" class="w-9 h-9 rounded-full bg-blue-500 border-4 border-gray-100 shadow-sm"></button>
                <button onclick="clearCanvas('drawing-canvas')" class="ml-auto text-[11px] text-red-500 font-bold px-3 py-1 bg-red-50 rounded-full border border-red-100">全消し</button>
            </div>
            <div class="canvas-container flex-grow border-x-2 border-b-2 border-gray-300 rounded-b-xl shadow-inner relative overflow-hidden bg-white">
                <div class="task-bg absolute inset-0 pointer-events-none"></div>
                <canvas id="drawing-canvas" class="absolute inset-0 z-10"></canvas>
                <canvas id="feedback-layer" class="absolute inset-0 z-20"></canvas>
            </div>
        </div>

        <div id="teacher-view" class="hidden bg-white p-3 rounded-xl border-2 border-blue-400 flex flex-wrap gap-3 items-center mb-2 flex-shrink-0 shadow-lg">
            <button onclick="openTaskCreateModal()" class="bg-blue-700 text-white px-6 py-2.5 rounded-full text-xs font-bold shadow-md hover:bg-blue-800 transition-colors">＋ 課題を作成して配信</button>
            <div class="text-[10px] text-blue-900 bg-blue-50 p-2 rounded flex-grow border border-blue-100">
                <span class="font-bold">ヒント:</span> 画像を貼り付けて、その上からペンで注釈を入れて配信できます。
            </div>
        </div>

        <div id="submissions-view" class="hidden flex-grow flex flex-col overflow-hidden">
            <div id="submissions-grid" class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 gap-4 overflow-y-auto pb-20 p-1"></div>
        </div>
    </div>

    <!-- 課題作成モーダル -->
    <div id="task-create-modal" class="fixed inset-0 bg-black bg-opacity-90 z-[100] hidden flex flex-col p-2 md:p-6">
        <div class="bg-white rounded-2xl flex flex-col h-full overflow-hidden shadow-2xl">
            <div class="bg-blue-800 text-white p-4 flex justify-between items-center">
                <h3 class="font-bold text-base">課題の作成・編集</h3>
                <button onclick="closeTaskCreateModal()" class="text-xs bg-gray-700 hover:bg-gray-600 px-4 py-2 rounded-full transition-colors">キャンセル</button>
            </div>
            <div class="p-3 border-b bg-gray-50 flex flex-wrap gap-4 items-center">
                <input type="text" id="task-title-input" placeholder="ここに課題のタイトルを入力" class="border-2 border-blue-100 p-2 rounded-lg text-sm flex-grow outline-none focus:border-blue-400">
                <label class="bg-blue-600 text-white px-5 py-2 rounded-full cursor-pointer text-xs font-bold shadow hover:bg-blue-700">
                    画像を挿入
                    <input type="file" accept="image/*" class="hidden" onchange="handleTaskImageUpload(event)">
                </label>
            </div>
            <div class="bg-white p-3 flex gap-5 items-center border-b">
                <button onclick="setPenColor('#000000')" class="w-8 h-8 rounded-full bg-black border-2 border-gray-200"></button>
                <button onclick="setPenColor('#ff0000')" class="w-8 h-8 rounded-full bg-red-600 border-2 border-gray-200"></button>
                <button onclick="setPenColor('#0000ff')" class="w-8 h-8 rounded-full bg-blue-600 border-2 border-gray-200"></button>
                <span class="text-[10px] text-gray-400">← 画像の上から書き込めます</span>
                <button onclick="clearCanvas('task-create-canvas')" class="ml-auto text-[10px] bg-red-50 text-red-600 border border-red-200 px-3 py-1.5 rounded-full font-bold">全リセット</button>
            </div>
            <div class="canvas-container flex-grow relative bg-white overflow-hidden">
                <!-- 【修正点】画像を下に、手書きを上に配置 -->
                <!-- 画像表示レイヤー (z-index: 10) -->
                <div id="task-image-overlay" class="absolute inset-0 z-10 pointer-events-none"></div>
                <!-- 手書きキャンバス (z-index: 20) -->
                <canvas id="task-create-canvas" class="absolute inset-0 z-20"></canvas>
            </div>
            <div class="p-4 bg-gray-100 text-center border-t">
                <button onclick="finalizeAndDistribute()" class="bg-green-600 hover:bg-green-700 text-white px-12 py-4 rounded-full font-black shadow-xl text-sm transition-all active:scale-95">
                    この内容で児童に配信する
                </button>
            </div>
        </div>
    </div>

    <!-- 添削モーダル -->
    <div id="feedback-modal" class="fixed inset-0 bg-black bg-opacity-95 z-[100] hidden flex flex-col p-2">
        <div class="flex justify-between items-center text-white mb-3 px-4 pt-2">
            <h3 class="font-bold text-sm">個別に添削・アドバイス</h3>
            <div class="flex gap-4">
                <button onclick="setPenColor('#ff0000')" class="w-10 h-10 rounded-full bg-red-600 border-4 border-white shadow-lg"></button>
                <button onclick="closeFeedbackModal()" class="bg-blue-600 px-8 py-2 rounded-full text-xs font-bold shadow-md">完了して閉じる</button>
            </div>
        </div>
        <div class="canvas-container flex-grow relative bg-white rounded-2xl overflow-hidden shadow-2xl">
            <div id="feedback-task-bg" class="absolute inset-0 bg-contain bg-center bg-no-repeat pointer-events-none opacity-100"></div>
            <div id="feedback-bg" class="absolute inset-0 bg-contain bg-center bg-no-repeat pointer-events-none opacity-100"></div>
            <canvas id="feedback-canvas" class="absolute inset-0 z-[110]"></canvas>
        </div>
    </div>
</body>
</html>
