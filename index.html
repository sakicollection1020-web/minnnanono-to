<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>EdTech Canvas Pro</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        * { -webkit-tap-highlight-color: transparent; box-sizing: border-box; }
        body { 
            touch-action: none; 
            -webkit-user-select: none; 
            user-select: none; 
            overflow: hidden; 
            position: fixed; 
            width: 100%; 
            height: 100%; 
            margin: 0; 
            padding: 0;
            background-color: #f3f4f6;
        }
        .canvas-container { position: relative; width: 100%; height: 100%; background: #fff; touch-action: none; }
        canvas { display: block; touch-action: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%; }
        #bg-canvas { z-index: 1; }
        #drawing-canvas { z-index: 2; }
        #feedback-canvas { z-index: 3; pointer-events: none; }
        
        #eraser-cursor {
            position: fixed;
            pointer-events: none;
            border: 2px solid #3b82f6;
            background: rgba(59, 130, 246, 0.2);
            border-radius: 50%;
            z-index: 9999;
            display: none;
            transform: translate(-50%, -50%);
        }

        .tool-btn.active { ring: 4px solid #3b82f6; scale: 1.1; }
        .tab-btn.active { background-color: #2563eb; color: white; }
        .loading-overlay {
            position: fixed; inset: 0; background: rgba(0,0,0,0.7);
            display: flex; justify-content: center; align-items: center;
            z-index: 10000; color: white; font-weight: bold;
        }
    </style>
</head>
<body class="flex flex-col">

    <div id="eraser-cursor"></div>
    <div id="loading" class="loading-overlay hidden">処理中...</div>

    <!-- ナビゲーション -->
    <nav class="bg-blue-900 text-white p-3 flex justify-between items-center shadow-lg z-50">
        <div class="flex items-center gap-4">
            <h1 class="font-bold text-sm tracking-tighter">EdTech Canvas Pro</h1>
            <div id="screen-tabs" class="flex bg-blue-800 rounded-lg p-1">
                <button onclick="window.switchScreen('main')" id="tab-main" class="tab-btn active px-3 py-1 rounded-md text-[10px] font-bold">メインノート</button>
                <button onclick="window.switchScreen('task')" id="tab-task" class="tab-btn px-3 py-1 rounded-md text-[10px] font-bold">課題作成</button>
                <button onclick="window.switchScreen('gallery')" id="tab-gallery" class="tab-btn px-3 py-1 rounded-md text-[10px] font-bold">みんなの回答</button>
            </div>
        </div>
        <div class="flex items-center gap-2">
            <span id="user-id-display" class="text-[9px] opacity-70 font-mono">未ログイン</span>
            <div class="bg-blue-800 px-3 py-1 rounded-full text-[10px] font-bold border border-blue-700" id="role-display">児童</div>
        </div>
    </nav>

    <!-- メインコンテンツ -->
    <div id="app-container" class="flex-grow flex flex-col p-2 overflow-hidden gap-2">
        
        <!-- ステータスバー -->
        <div class="bg-white p-2 rounded-lg shadow-sm border-l-4 border-blue-600 flex justify-between items-center">
            <div class="flex items-center gap-2">
                <div id="status-indicator" class="w-2 h-2 rounded-full bg-gray-400"></div>
                <h2 id="current-task-name" class="text-xs font-bold text-gray-700">読み込み中...</h2>
            </div>
            <div id="teacher-tools" class="hidden flex gap-2">
                <button onclick="window.distributeTask()" class="bg-indigo-600 text-white text-[10px] px-3 py-1 rounded-full font-bold shadow-sm">全員に配信</button>
            </div>
        </div>

        <!-- ツールバー -->
        <div id="toolbar" class="bg-gray-900 p-2 rounded-xl shadow-2xl flex flex-wrap gap-4 items-center border border-gray-700">
            <div class="flex gap-1.5 border-r border-gray-700 pr-4">
                <button onclick="window.setPen('#000000')" data-color="#000000" class="tool-btn w-8 h-8 rounded-full bg-black border-2 border-gray-400 active:scale-90 transition-transform"></button>
                <button onclick="window.setPen('#ef4444')" data-color="#ef4444" class="tool-btn w-8 h-8 rounded-full bg-red-500 border-2 border-gray-400 active:scale-90 transition-transform"></button>
                <button onclick="window.setPen('#3b82f6')" data-color="#3b82f6" class="tool-btn w-8 h-8 rounded-full bg-blue-500 border-2 border-gray-400 active:scale-90 transition-transform"></button>
                <button onclick="window.setEraser()" id="eraser-btn" class="tool-btn w-8 h-8 rounded-full bg-white border-2 border-gray-400 flex items-center justify-center active:scale-90 transition-transform">
                    <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" class="text-gray-800"><path d="m7 21-4.3-4.3c-1-1-1-2.5 0-3.4l9.9-9.9c1-1 2.5-1 3.4 0l4.4 4.4c1 1 1 2.5 0 3.4L10.5 21z"/><path d="m15 5 4 4"/></svg>
                </button>
            </div>

            <div class="flex items-center gap-3 bg-gray-800 px-4 py-1.5 rounded-full border border-gray-700">
                <span class="text-[10px] font-black text-gray-400 uppercase tracking-widest">Size</span>
                <input type="range" min="2" max="100" value="5" class="w-24 md:w-32 accent-blue-500" id="size-slider" oninput="window.updateBrushSize(this.value)">
                <div id="size-preview" class="w-4 h-4 rounded-full bg-white shadow-inner"></div>
            </div>

            <div class="ml-auto flex gap-2">
                <button onclick="window.clearCanvas()" class="text-[10px] text-gray-400 font-bold px-3 py-1 hover:text-white transition-colors">リセット</button>
                <button onclick="window.saveToCloud()" class="bg-blue-600 text-white text-[10px] px-5 py-1.5 rounded-full font-bold shadow-lg hover:bg-blue-500 active:scale-95 transition-all">保存して提出</button>
            </div>
        </div>

        <!-- キャンバスエリア -->
        <div id="canvas-area" class="canvas-container flex-grow rounded-2xl shadow-inner border-2 border-gray-200 overflow-hidden">
            <canvas id="bg-canvas"></canvas>
            <canvas id="drawing-canvas"></canvas>
            <canvas id="feedback-canvas"></canvas>
        </div>
    </div>

    <!-- ギャラリー表示 -->
    <div id="gallery-container" class="hidden flex-grow overflow-y-auto p-4">
        <div id="gallery-grid" class="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-4"></div>
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, setDoc, onSnapshot, collection, getDoc, query, deleteDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        const firebaseConfig = JSON.parse(__firebase_config);
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'edtech-canvas-pro';

        let user = null;
        let isDrawing = false;
        let currentMode = 'pen';
        let brushColor = '#000000';
        let brushSize = 5;
        let eraserSize = 40;
        let isTeacher = false;

        const canvases = {
            bg: document.getElementById('bg-canvas'),
            draw: document.getElementById('drawing-canvas'),
            feedback: document.getElementById('feedback-canvas')
        };
        const ctxs = {
            bg: canvases.bg.getContext('2d'),
            draw: canvases.draw.getContext('2d'),
            feedback: canvases.feedback.getContext('2d')
        };
        const eraserCursor = document.getElementById('eraser-cursor');

        const initAuth = async () => {
            try {
                if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                    await signInWithCustomToken(auth, __initial_auth_token).catch(() => signInAnonymously(auth));
                } else {
                    await signInAnonymously(auth);
                }
            } catch (error) { console.error("Auth error:", error); }
        };

        onAuthStateChanged(auth, (u) => {
            user = u;
            if (user) {
                document.getElementById('user-id-display').innerText = `ID: ${user.uid.substring(0, 8)}`;
                document.getElementById('status-indicator').classList.replace('bg-gray-400', 'bg-green-500');
                if (user.uid.startsWith('admin') || window.location.search.includes('role=teacher')) {
                    isTeacher = true;
                    document.getElementById('role-display').innerText = '先生';
                    document.getElementById('teacher-tools').classList.remove('hidden');
                }
                loadData();
            }
        });

        function loadData() {
            if (!user) return;
            const taskDoc = doc(db, 'artifacts', appId, 'public', 'data', 'config', 'current_task');
            onSnapshot(taskDoc, (snap) => {
                if (snap.exists()) {
                    const data = snap.data();
                    const img = new Image();
                    img.onload = () => {
                        ctxs.bg.clearRect(0, 0, canvases.bg.width, canvases.bg.height);
                        ctxs.bg.drawImage(img, 0, 0, canvases.bg.width, canvases.bg.height);
                    };
                    img.src = data.image;
                    document.getElementById('current-task-name').innerText = data.name || "課題実施中";
                }
            });

            const myDoc = doc(db, 'artifacts', appId, 'users', user.uid, 'drawings', 'latest');
            onSnapshot(myDoc, (snap) => {
                if (!isDrawing) {
                    ctxs.draw.clearRect(0, 0, canvases.draw.width, canvases.draw.height);
                    if (snap.exists()) {
                        const img = new Image();
                        img.onload = () => ctxs.draw.drawImage(img, 0, 0, canvases.draw.width, canvases.draw.height);
                        img.src = snap.data().image;
                    }
                }
            });
            
            const feedbackDoc = doc(db, 'artifacts', appId, 'users', user.uid, 'feedback', 'latest');
            onSnapshot(feedbackDoc, (snap) => {
                ctxs.feedback.clearRect(0, 0, canvases.feedback.width, canvases.feedback.height);
                if (snap.exists()) {
                    const img = new Image();
                    img.onload = () => ctxs.feedback.drawImage(img, 0, 0, canvases.feedback.width, canvases.feedback.height);
                    img.src = snap.data().image;
                }
            });
        }

        window.saveToCloud = async () => {
            if (!user) return;
            document.getElementById('loading').classList.remove('hidden');
            const dataUrl = canvases.draw.toDataURL();
            try {
                await setDoc(doc(db, 'artifacts', appId, 'users', user.uid, 'drawings', 'latest'), {
                    image: dataUrl,
                    updatedAt: new Date().getTime()
                });
                await setDoc(doc(db, 'artifacts', appId, 'public', 'data', 'submissions', user.uid), {
                    image: dataUrl,
                    userId: user.uid,
                    updatedAt: new Date().getTime()
                });
            } catch (e) { console.error(e); }
            finally { document.getElementById('loading').classList.add('hidden'); }
        };

        function getPos(e) {
            const rect = canvases.draw.getBoundingClientRect();
            const clientX = e.clientX || (e.touches && e.touches[0].clientX);
            const clientY = e.clientY || (e.touches && e.touches[0].clientY);
            return {
                x: (clientX - rect.left) * (canvases.draw.width / rect.width),
                y: (clientY - rect.top) * (canvases.draw.height / rect.height)
            };
        }

        function updateEraserGuide(e) {
            if (currentMode !== 'eraser') { eraserCursor.style.display = 'none'; return; }
            const clientX = e.clientX || (e.touches && e.touches[0].clientX);
            const clientY = e.clientY || (e.touches && e.touches[0].clientY);
            if (clientX !== undefined) {
                eraserCursor.style.display = 'block';
                eraserCursor.style.width = eraserCursor.style.height = `${eraserSize}px`;
                eraserCursor.style.left = `${clientX}px`;
                eraserCursor.style.top = `${clientY}px`;
            }
        }

        function start(e) {
            if (!user) return;
            isDrawing = true;
            const pos = getPos(e);
            ctxs.draw.beginPath();
            ctxs.draw.moveTo(pos.x, pos.y);
            updateEraserGuide(e);
        }

        function move(e) {
            updateEraserGuide(e);
            if (!isDrawing) return;
            if (e.cancelable) e.preventDefault();
            const pos = getPos(e);
            ctxs.draw.lineCap = 'round';
            ctxs.draw.lineJoin = 'round';
            if (currentMode === 'eraser') {
                ctxs.draw.globalCompositeOperation = 'destination-out';
                ctxs.draw.lineWidth = eraserSize;
            } else {
                ctxs.draw.globalCompositeOperation = 'source-over';
                ctxs.draw.strokeStyle = brushColor;
                ctxs.draw.lineWidth = brushSize;
            }
            ctxs.draw.lineTo(pos.x, pos.y);
            ctxs.draw.stroke();
        }

        function stop() { isDrawing = false; eraserCursor.style.display = 'none'; }

        window.setPen = (color) => {
            currentMode = 'pen';
            brushColor = color;
            document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
            document.querySelector(`[data-color="${color}"]`)?.classList.add('active');
            updateUI();
        };

        window.setEraser = () => {
            currentMode = 'eraser';
            document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
            document.getElementById('eraser-btn').classList.add('active');
            updateUI();
        };

        window.updateBrushSize = (val) => {
            if (currentMode === 'eraser') eraserSize = parseInt(val);
            else brushSize = parseInt(val);
            updateUI();
        };

        function updateUI() {
            const preview = document.getElementById('size-preview');
            const slider = document.getElementById('size-slider');
            if (currentMode === 'eraser') {
                slider.value = eraserSize;
                preview.style.backgroundColor = '#cbd5e1';
                preview.style.width = preview.style.height = `${Math.max(4, eraserSize/5)}px`;
            } else {
                slider.value = brushSize;
                preview.style.backgroundColor = brushColor;
                preview.style.width = preview.style.height = `${Math.max(4, brushSize/2)}px`;
            }
        }

        // --- 全員リセット（添削も削除）機能 ---
        window.clearCanvas = async () => {
            if (!user) return;
            if (confirm('自分の描画と、先生からの添削（赤い線など）をすべて消去しますか？')) {
                document.getElementById('loading').classList.remove('hidden');
                
                try {
                    // 1. ローカル画面（キャンバス）をクリア
                    ctxs.draw.clearRect(0, 0, canvases.draw.width, canvases.draw.height);
                    ctxs.feedback.clearRect(0, 0, canvases.feedback.width, canvases.feedback.height);

                    // 2. クラウド上の自分の描画データを削除
                    await deleteDoc(doc(db, 'artifacts', appId, 'users', user.uid, 'drawings', 'latest'));
                    
                    // 3. クラウド上の先生からの添削データを削除
                    await deleteDoc(doc(db, 'artifacts', appId, 'users', user.uid, 'feedback', 'latest'));
                    
                    // 4. 公開用の提出データも更新（または削除）
                    await deleteDoc(doc(db, 'artifacts', appId, 'public', 'data', 'submissions', user.uid));

                    alert('リセットが完了しました。');
                } catch (e) {
                    console.error(e);
                    alert('一部のデータの削除に失敗しました。');
                } finally {
                    document.getElementById('loading').classList.add('hidden');
                }
            }
        };

        window.switchScreen = (screen) => {
            document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
            document.getElementById(`tab-${screen}`).classList.add('active');
            document.getElementById('app-container').classList.toggle('hidden', screen === 'gallery');
            document.getElementById('gallery-container').classList.toggle('hidden', screen !== 'gallery');
            if (screen === 'gallery') loadGallery();
        };

        async function loadGallery() {
            const grid = document.getElementById('gallery-grid');
            grid.innerHTML = '<div class="col-span-full text-center py-10 text-gray-400">読み込み中...</div>';
            const subCol = collection(db, 'artifacts', appId, 'public', 'data', 'submissions');
            onSnapshot(subCol, (snap) => {
                grid.innerHTML = '';
                if (snap.empty) {
                    grid.innerHTML = '<div class="col-span-full text-center py-10">まだ提出がありません</div>';
                    return;
                }
                snap.docs.forEach(d => {
                    const data = d.data();
                    const card = document.createElement('div');
                    card.className = "bg-white p-2 rounded-lg shadow border";
                    card.innerHTML = `<img src="${data.image}" class="w-full h-auto bg-gray-50 rounded border mb-1"><div class="text-[8px] text-gray-500 font-bold truncate">ユーザー: ${data.userId?.substring(0,8)}</div>`;
                    grid.appendChild(card);
                });
            });
        }

        function resize() {
            const area = document.getElementById('canvas-area');
            if (!area) return;
            const w = area.clientWidth, h = area.clientHeight;
            Object.keys(canvases).forEach(k => {
                const c = canvases[k];
                const temp = c.toDataURL();
                c.width = w; c.height = h;
                const img = new Image();
                img.onload = () => ctxs[k].drawImage(img, 0, 0, w, h);
                img.src = temp;
            });
        }

        window.distributeTask = async () => {
            if (!isTeacher) return;
            const dataUrl = canvases.draw.toDataURL();
            try {
                await setDoc(doc(db, 'artifacts', appId, 'public', 'data', 'config', 'current_task'), {
                    image: dataUrl,
                    name: prompt('課題名', '新しい課題'),
                    updatedAt: new Date().getTime()
                });
                alert('配信完了');
            } catch (e) { alert('配信エラー'); }
        };

        window.onload = () => {
            resize();
            initAuth();
            window.setPen('#000000');
            canvases.draw.addEventListener('mousedown', start);
            window.addEventListener('mousemove', move);
            window.addEventListener('mouseup', stop);
            canvases.draw.addEventListener('touchstart', start, { passive: false });
            canvases.draw.addEventListener('touchmove', move, { passive: false });
            canvases.draw.addEventListener('touchend', stop);
        };
        window.onresize = resize;
    </script>
</body>
</html>
