<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>EdTech Canvas Pro</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, setDoc, onSnapshot, collection, getDoc, writeBatch, getDocs } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        const firebaseConfig = {
            apiKey: "AIzaSyD2UPzm5FauzRDMUi_iv-5PQDG391xL_Eo",
            authDomain: "minnnano-no-to.firebaseapp.com",
            projectId: "minnnano-no-to",
            storageBucket: "minnnano-no-to.firebasestorage.app",
            messagingSenderId: "589337230554",
            appId: "1:589337230554:web:6c564cb5bbe08573ceb9e3"
        };

        // Initialize state
        window.state = {
            user: null,
            role: 'student',
            roomName: '', 
            viewMode: 'mine', 
            userName: '',
            currentTask: "課題を待っています...",
            isPublic: false,
            isDrawing: false,
            brushColor: '#000000',
            brushSize: 4,
            isEraser: false,
            bgImage: null,
            editingStudentId: null,
            isTaskCreating: false,
            floatingImages: [],
            selectedImageIdx: -1,
            isResizing: false,
            isDraggingImage: false
        };

        let app, auth, db;
        try {
            app = initializeApp(firebaseConfig);
            auth = getAuth(app);
            db = getFirestore(app);
            window.db = db;
        } catch (e) {
            console.error("Firebase initialization failed", e);
        }

        const appId = typeof __app_id !== 'undefined' ? __app_id : 'edtech-canvas-pro';
        window.appId = appId;

        window.getElements = () => {
            window.canvas = document.getElementById('drawing-canvas');
            window.feedbackCanvas = document.getElementById('feedback-canvas');
            window.taskCreateCanvas = document.getElementById('task-create-canvas');
        };

        function normalizeId(str) {
            if (!str) return "";
            return str.replace(/[Ａ-Ｚａ-ｚ０-９]/g, (s) => {
                return String.fromCharCode(s.charCodeAt(0) - 0xFEE0);
            }).toLowerCase().replace(/\s+/g, '');
        }

        window.onload = async () => {
            window.getElements();
            checkUrlParams(); 
            
            if (!window.state.roomName) {
                const savedRoom = localStorage.getItem('school_note_room_name');
                let room = prompt("クラス名（合言葉）を入力してください\n(例: 3A, math, science)", savedRoom || "");
                if (!room) room = "default";
                window.state.roomName = normalizeId(room);
                localStorage.setItem('school_note_room_name', window.state.roomName);
            }

            if (!window.state.userName) {
                const savedName = localStorage.getItem('school_note_user_name');
                const name = prompt("あなたのなまえを入力してください", savedName || "");
                window.state.userName = name || (window.state.role === 'teacher' ? "先生" : "ゲスト") + "_" + Math.floor(Math.random() * 1000);
                localStorage.setItem('school_note_user_name', window.state.userName);
            }

            setTimeout(window.setupMainCanvas, 100);
            window.addEventListener('resize', window.setupMainCanvas);
            
            window.updateUI();
            setupEventListeners(window.canvas); 
            setupEventListeners(window.feedbackCanvas);
            setupTaskCreateListeners(window.taskCreateCanvas);

            document.addEventListener('paste', handlePaste);

            if (!auth) return;

            const initAuth = async () => {
                try {
                    if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                        try {
                            await signInWithCustomToken(auth, __initial_auth_token);
                        } catch (tokenError) {
                            await signInAnonymously(auth);
                        }
                    } else {
                        await signInAnonymously(auth);
                    }
                } catch (error) {}
            };

            onAuthStateChanged(auth, (user) => {
                if (user) {
                    window.state.user = user;
                    initSync();
                    window.updateUI();
                    syncCanvas();
                }
            });

            await initAuth();
        };

        function getRoomDoc(subCol, docId) {
            return doc(window.db, 'artifacts', window.appId, 'public', 'data', `room_${window.state.roomName}_${subCol}`, docId);
        }
        function getRoomCollection(subCol) {
            return collection(window.db, 'artifacts', window.appId, 'public', 'data', `room_${window.state.roomName}_${subCol}`);
        }

        function initSync() {
            if (!window.db || !window.state.roomName || !window.state.user) return;

            const settingsRef = getRoomDoc('settings', 'current');
            onSnapshot(settingsRef, (snap) => {
                if (snap.exists()) {
                    const data = snap.data();
                    window.state.currentTask = data.taskTitle || "課題を待っています...";
                    window.state.bgImage = data.bgImage || null;
                    window.state.isPublic = data.isPublic || false;
                    if (window.state.role === 'student' && !window.state.isPublic) window.state.viewMode = 'mine';
                    window.applyBg();
                    window.updateUI();
                }
            });

            if (window.state.role === 'student') {
                onSnapshot(getRoomDoc('submissions', window.state.user.uid), (snap) => {
                    const feedbackLayer = document.getElementById('feedback-layer');
                    if (snap.exists()) {
                        const data = snap.data();
                        if (data.feedbackData) renderFeedback(data.feedbackData);
                        else if (feedbackLayer) feedbackLayer.getContext('2d').clearRect(0, 0, feedbackLayer.width, feedbackLayer.height);
                        
                        if (data.canvasData === null) {
                            const tctx = window.canvas.getContext('2d');
                            tctx.clearRect(0, 0, window.canvas.width, window.canvas.height);
                        }
                    }
                });
            }

            onSnapshot(getRoomCollection('submissions'), (snap) => {
                const list = [];
                snap.forEach(doc => {
                    const d = doc.data();
                    list.push(d);
                });
                renderSubmissionsGrid(list);
            });
        }

        function renderFeedback(dataUrl) {
            if (!dataUrl) return;
            const img = new Image();
            img.onload = () => {
                const feedbackLayer = document.getElementById('feedback-layer');
                if (feedbackLayer) {
                    const fctxL = feedbackLayer.getContext('2d');
                    fctxL.clearRect(0, 0, feedbackLayer.width, feedbackLayer.height);
                    fctxL.drawImage(img, 0, 0, feedbackLayer.width, feedbackLayer.height);
                }
            };
            img.src = dataUrl;
        }

        async function syncCanvas() {
            if (!window.state.user || !window.db || !window.state.roomName) return;
            if (window.state.role === 'student') {
                const dataUrl = window.canvas.toDataURL('image/webp', 0.5);
                await setDoc(getRoomDoc('submissions', window.state.user.uid), {
                    uid: window.state.user.uid,
                    name: window.state.userName,
                    canvasData: dataUrl,
                    lastUpdate: Date.now()
                }, { merge: true });
            }
            if (window.state.role === 'teacher' && window.state.editingStudentId) {
                const feedbackDataUrl = window.feedbackCanvas.toDataURL('image/webp', 0.5);
                await setDoc(getRoomDoc('submissions', window.state.editingStudentId), {
                    feedbackData: feedbackDataUrl,
                    lastUpdate: Date.now()
                }, { merge: true });
            }
        }
        window.syncCanvas = syncCanvas;

        window.setupMainCanvas = () => {
            if (!window.canvas) window.getElements();
            const container = window.canvas.parentElement;
            if (!container) return;
            const navH = document.querySelector('nav').offsetHeight;
            const taskH = document.getElementById('task-container').offsetHeight;
            const switchH = (window.state.role === 'student' && window.state.isPublic) ? document.getElementById('view-switch').offsetHeight : 0;
            const toolH = document.getElementById('student-tools')?.offsetHeight || 0;
            const teacherToolH = (window.state.role === 'teacher' && !document.getElementById('teacher-view').classList.contains('hidden')) ? document.getElementById('teacher-view').offsetHeight : 0;
            const windowH = window.innerHeight;
            const availableH = windowH - navH - taskH - switchH - toolH - teacherToolH - 40;
            const rect = container.getBoundingClientRect();
            
            const temp = document.createElement('canvas');
            temp.width = window.canvas.width;
            temp.height = window.canvas.height;
            if (window.canvas.width > 0) temp.getContext('2d').drawImage(window.canvas, 0, 0);
            
            window.canvas.width = rect.width;
            window.canvas.height = Math.max(300, availableH);
            const feedbackLayer = document.getElementById('feedback-layer');
            feedbackLayer.width = window.canvas.width;
            feedbackLayer.height = window.canvas.height;
            
            if (temp.width > 0) window.canvas.getContext('2d').drawImage(temp, 0, 0, window.canvas.width, window.canvas.height);
            window.applyBg();
        };

        function setupEventListeners(targetCanvas) {
            const getPos = (e) => {
                const rect = targetCanvas.getBoundingClientRect();
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                return { 
                    x: (clientX - rect.left) * (targetCanvas.width / rect.width), 
                    y: (clientY - rect.top) * (targetCanvas.height / rect.height)
                };
            };
            const start = (e) => {
                if (window.state.role === 'student' && window.state.viewMode === 'others') return;
                window.state.isDrawing = true;
                const tctx = targetCanvas.getContext('2d');
                const pos = getPos(e);
                tctx.beginPath();
                tctx.moveTo(pos.x, pos.y);
            };
            const move = (e) => {
                if (!window.state.isDrawing) return;
                const tctx = targetCanvas.getContext('2d');
                const pos = getPos(e);
                
                // 消しゴムモードかどうかの判定
                if (window.state.isEraser) {
                    tctx.globalCompositeOperation = 'destination-out';
                    tctx.lineWidth = 20; // 消しゴムは太め
                } else {
                    tctx.globalCompositeOperation = 'source-over';
                    tctx.strokeStyle = window.state.brushColor;
                    tctx.lineWidth = window.state.brushSize;
                }
                
                tctx.lineJoin = 'round';
                tctx.lineCap = 'round';
                tctx.lineTo(pos.x, pos.y);
                tctx.stroke();
            };
            const stop = () => {
                if (window.state.isDrawing) {
                    window.state.isDrawing = false;
                    window.syncCanvas();
                }
            };
            targetCanvas.addEventListener('mousedown', start);
            targetCanvas.addEventListener('mousemove', move);
            window.addEventListener('mouseup', stop);
            targetCanvas.addEventListener('touchstart', (e) => { if (window.state.role === 'student' && window.state.viewMode === 'others') return; start(e); }, {passive: false});
            targetCanvas.addEventListener('touchmove', (e) => { if (window.state.role === 'student' && window.state.viewMode === 'others') return; e.preventDefault(); move(e); }, {passive: false});
            targetCanvas.addEventListener('touchend', stop);
        }

        function handlePaste(e) {
            if (!window.state.isTaskCreating) return;
            const items = (e.clipboardData || e.originalEvent.clipboardData).items;
            for (let item of items) {
                if (item.type.indexOf("image") !== -1) {
                    const blob = item.getAsFile();
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        const img = new Image();
                        img.onload = () => {
                            window.state.floatingImages.push({
                                img: img,
                                x: 50,
                                y: 50,
                                w: img.width > 400 ? 400 : img.width,
                                h: img.width > 400 ? (img.height * (400 / img.width)) : img.height
                            });
                            window.drawTaskCreateCanvas();
                        };
                        img.src = event.target.result;
                    };
                    reader.readAsDataURL(blob);
                }
            }
        }

        function setupTaskCreateListeners(targetCanvas) {
            let lastX, lastY;
            const getPos = (e) => {
                const rect = targetCanvas.getBoundingClientRect();
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                return { 
                    x: (clientX - rect.left) * (targetCanvas.width / rect.width), 
                    y: (clientY - rect.top) * (targetCanvas.height / rect.height)
                };
            };
            const start = (e) => {
                const pos = getPos(e);
                lastX = pos.x; lastY = pos.y;
                window.state.selectedImageIdx = -1;
                window.state.isResizing = false;
                window.state.isDraggingImage = false;
                for (let i = window.state.floatingImages.length - 1; i >= 0; i--) {
                    const img = window.state.floatingImages[i];
                    if (pos.x > img.x + img.w - 40 && pos.x < img.x + img.w + 20 &&
                        pos.y > img.y + img.h - 40 && pos.y < img.y + img.h + 20) {
                        window.state.selectedImageIdx = i;
                        window.state.isResizing = true;
                        break;
                    }
                    if (pos.x > img.x && pos.x < img.x + img.w && pos.y > img.y && pos.y < img.y + img.h) {
                        window.state.selectedImageIdx = i;
                        window.state.isDraggingImage = true;
                        break;
                    }
                }
                if (window.state.selectedImageIdx === -1) {
                    window.state.isDrawing = true;
                    const ctx = targetCanvas.getContext('2d');
                    ctx.beginPath();
                    ctx.moveTo(pos.x, pos.y);
                }
                window.drawTaskCreateCanvas();
            };
            const move = (e) => {
                const pos = getPos(e);
                const dx = pos.x - lastX;
                const dy = pos.y - lastY;
                if (window.state.selectedImageIdx !== -1) {
                    const img = window.state.floatingImages[window.state.selectedImageIdx];
                    if (window.state.isResizing) {
                        img.w = Math.max(50, img.w + dx);
                        img.h = Math.max(50, img.h + dy);
                    } else if (window.state.isDraggingImage) {
                        img.x += dx;
                        img.y += dy;
                    }
                    window.drawTaskCreateCanvas();
                } else if (window.state.isDrawing) {
                    const ctx = targetCanvas.getContext('2d');
                    if (window.state.isEraser) {
                        ctx.globalCompositeOperation = 'destination-out';
                        ctx.lineWidth = 20;
                    } else {
                        ctx.globalCompositeOperation = 'source-over';
                        ctx.strokeStyle = window.state.brushColor;
                        ctx.lineWidth = window.state.brushSize;
                    }
                    ctx.lineJoin = 'round';
                    ctx.lineCap = 'round';
                    ctx.lineTo(pos.x, pos.y);
                    ctx.stroke();
                }
                lastX = pos.x; lastY = pos.y;
            };
            const stop = () => {
                window.state.isDrawing = false;
                window.state.isResizing = false;
                window.state.isDraggingImage = false;
            };
            targetCanvas.addEventListener('mousedown', start);
            targetCanvas.addEventListener('mousemove', move);
            window.addEventListener('mouseup', stop);
            targetCanvas.addEventListener('touchstart', (e) => start(e), {passive: false});
            targetCanvas.addEventListener('touchmove', (e) => { e.preventDefault(); move(e); }, {passive: false});
            window.addEventListener('touchend', stop);
        }

        window.drawTaskCreateCanvas = () => {
            const overlay = document.getElementById('task-image-overlay');
            if (!overlay) return;
            overlay.innerHTML = '';
            window.state.floatingImages.forEach((imgData, idx) => {
                const imgWrap = document.createElement('div');
                imgWrap.className = `absolute border-2 ${window.state.selectedImageIdx === idx ? 'border-blue-500 shadow-2xl z-30' : 'border-gray-300 z-20'}`;
                imgWrap.style.left = `${imgData.x}px`;
                imgWrap.style.top = `${imgData.y}px`;
                imgWrap.style.width = `${imgData.w}px`;
                imgWrap.style.height = `${imgData.h}px`;
                imgWrap.style.backgroundImage = `url(${imgData.img.src})`;
                imgWrap.style.backgroundSize = '100% 100%';
                imgWrap.style.pointerEvents = 'none'; 
                if (window.state.selectedImageIdx === idx) {
                    const handle = document.createElement('div');
                    handle.className = "absolute right-[-15px] bottom-[-15px] w-8 h-8 bg-blue-600 rounded-full border-2 border-white flex items-center justify-center shadow-lg pointer-events-none";
                    handle.innerHTML = `<svg width="16" height="16" viewBox="0 0 24 24" fill="white"><path d="M21 15v6h-6M9 3H3v6M21 3l-6 6M3 21l6-6"/></svg>`;
                    imgWrap.appendChild(handle);
                    const del = document.createElement('div');
                    del.className = "absolute left-[-15px] top-[-15px] w-8 h-8 bg-red-600 text-white rounded-full flex items-center justify-center text-[14px] font-bold cursor-pointer pointer-events-auto shadow-md";
                    del.textContent = '×';
                    del.onclick = (e) => {
                        e.stopPropagation();
                        window.state.floatingImages.splice(idx, 1);
                        window.state.selectedImageIdx = -1;
                        window.drawTaskCreateCanvas();
                    };
                    imgWrap.appendChild(del);
                }
                overlay.appendChild(imgWrap);
            });
        };

        window.openTaskCreateModal = () => {
            window.state.isTaskCreating = true;
            window.state.floatingImages = [];
            window.state.selectedImageIdx = -1;
            window.state.isEraser = false;
            window.state.brushColor = '#000000';
            const modal = document.getElementById('task-create-modal');
            modal.classList.remove('hidden');
            const container = window.taskCreateCanvas.parentElement;
            const rect = container.getBoundingClientRect();
            window.taskCreateCanvas.width = rect.width;
            window.taskCreateCanvas.height = rect.height;
            const ctx = window.taskCreateCanvas.getContext('2d');
            ctx.clearRect(0, 0, window.taskCreateCanvas.width, window.taskCreateCanvas.height);
            document.getElementById('task-title-input').value = "";
            window.drawTaskCreateCanvas();
            window.updateToolStyles();
        };

        window.closeTaskCreateModal = () => {
            window.state.isTaskCreating = false;
            document.getElementById('task-create-modal').classList.add('hidden');
        };

        window.handleTaskImageUpload = (e) => {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (event) => {
                const img = new Image();
                img.onload = () => {
                    window.state.floatingImages.push({
                        img: img,
                        x: 100,
                        y: 100,
                        w: img.width > 400 ? 400 : img.width,
                        h: img.width > 400 ? (img.height * (400 / img.width)) : img.height
                    });
                    window.drawTaskCreateCanvas();
                };
                img.src = event.target.result;
            };
            reader.readAsDataURL(file);
        };

        window.finalizeAndDistribute = async () => {
            const title = document.getElementById('task-title-input').value || "新しい課題";
            const offscreen = document.createElement('canvas');
            offscreen.width = window.taskCreateCanvas.width;
            offscreen.height = window.taskCreateCanvas.height;
            const octx = offscreen.getContext('2d');
            octx.fillStyle = "#ffffff";
            octx.fillRect(0, 0, offscreen.width, offscreen.height);
            for (let imgData of window.state.floatingImages) {
                octx.drawImage(imgData.img, imgData.x, imgData.y, imgData.w, imgData.h);
            }
            // 描画部分（消しゴムを反映させるために合成モードを意識して描画）
            octx.drawImage(window.taskCreateCanvas, 0, 0);
            
            const finalDataUrl = offscreen.toDataURL('image/jpeg', 0.8); 
            if (confirm("この内容をクラス全員に配信しますか？")) {
                await setDoc(getRoomDoc('settings', 'current'), { 
                    taskTitle: title, 
                    bgImage: finalDataUrl,
                    lastDistribute: Date.now()
                });
                alert("配信しました！");
                window.closeTaskCreateModal();
            }
        };

        window.openPreviewModal = async (uid, name) => {
            window.state.editingStudentId = uid;
            window.state.brushColor = '#ff0000';
            window.state.isEraser = false;
            const modal = document.getElementById('feedback-modal');
            modal.classList.remove('hidden');
            
            const container = window.feedbackCanvas.parentElement;
            const rect = container.getBoundingClientRect();
            window.feedbackCanvas.width = rect.width;
            window.feedbackCanvas.height = rect.height;

            const snap = await getDoc(getRoomDoc('submissions', uid));
            if (snap.exists()) {
                const data = snap.data();
                
                const feedbackTaskBg = document.getElementById('feedback-task-bg');
                if (window.state.bgImage) {
                    feedbackTaskBg.style.backgroundImage = `url(${window.state.bgImage})`;
                } else {
                    feedbackTaskBg.style.backgroundImage = 'none';
                }

                const feedbackBg = document.getElementById('feedback-bg');
                if (data.canvasData) {
                    feedbackBg.style.backgroundImage = `url(${data.canvasData})`;
                } else {
                    feedbackBg.style.backgroundImage = 'none';
                }

                const fctx = window.feedbackCanvas.getContext('2d');
                fctx.clearRect(0, 0, window.feedbackCanvas.width, window.feedbackCanvas.height);
                if (data.feedbackData) {
                    const img = new Image();
                    img.onload = () => fctx.drawImage(img, 0, 0, window.feedbackCanvas.width, window.feedbackCanvas.height);
                    img.src = data.feedbackData;
                }
            }
            window.updateToolStyles();
        };

        window.closeFeedbackModal = () => {
            window.state.editingStudentId = null;
            document.getElementById('feedback-modal').classList.add('hidden');
        };

        window.switchView = (mode) => {
            if (mode === 'others' && !window.state.isPublic && window.state.role === 'student') return;
            window.state.viewMode = mode;
            window.updateUI();
            setTimeout(window.setupMainCanvas, 50);
        };

        window.togglePublic = async () => {
            const newVal = !window.state.isPublic;
            await setDoc(getRoomDoc('settings', 'current'), { isPublic: newVal }, { merge: true });
        };

        window.clearCanvas = (id) => {
            if (confirm("すべて消去しますか？")) {
                const target = document.getElementById(id);
                const tctx = target.getContext('2d');
                tctx.clearRect(0, 0, target.width, target.height);
                if (id === 'task-create-canvas') {
                    window.state.floatingImages = [];
                    window.state.selectedImageIdx = -1;
                    window.drawTaskCreateCanvas();
                } else {
                    window.syncCanvas();
                }
            }
        };

        window.resetStudentCanvas = async () => {
            if (!window.state.editingStudentId) return;
            if (confirm("この児童の回答をすべて消去しますか？")) {
                await setDoc(getRoomDoc('submissions', window.state.editingStudentId), {
                    canvasData: null, 
                    feedbackData: "",
                    lastUpdate: Date.now()
                }, { merge: true });
                window.closeFeedbackModal();
                alert("リセットしました。");
            }
        };

        window.resetAllCanvases = async () => {
            if (confirm("クラス全員の回答をすべて消去しますか？\n(この操作は取り消せません)")) {
                const batch = writeBatch(window.db);
                const querySnapshot = await getDocs(getRoomCollection('submissions'));
                querySnapshot.forEach((doc) => {
                    batch.update(doc.ref, { 
                        canvasData: null, 
                        feedbackData: "",
                        lastUpdate: Date.now() 
                    });
                });
                await batch.commit();
                alert("全員の回答をリセットしました。");
            }
        };

        window.applyBg = () => {
            const bgs = document.querySelectorAll('.task-bg');
            bgs.forEach(bg => {
                if (window.state.bgImage) {
                    bg.style.backgroundImage = `url(${window.state.bgImage})`;
                    bg.style.backgroundSize = 'contain';
                    bg.style.backgroundPosition = 'center';
                    bg.style.backgroundRepeat = 'no-repeat';
                    bg.style.opacity = "1";
                }
            });
        };

        function renderSubmissionsGrid(list) {
            const grid = document.getElementById('submissions-grid');
            if (!grid) return;
            grid.innerHTML = '';
            
            list.sort((a, b) => {
                const nameA = a.name || "";
                const nameB = b.name || "";
                return nameA.localeCompare(nameB, 'ja');
            });

            list.forEach(data => {
                const div = document.createElement('div');
                div.className = "bg-white p-1 border border-gray-200 rounded-md shadow-sm cursor-pointer hover:border-blue-400 relative h-auto overflow-hidden transition-all active:scale-95";
                
                const bgImgHtml = window.state.bgImage ? `<img src="${window.state.bgImage}" class="absolute inset-0 w-full h-full object-contain z-10">` : '';
                
                let canvasImgHtml = '';
                if (data.canvasData) {
                    canvasImgHtml = `<img src="${data.canvasData}" class="absolute inset-0 w-full h-full object-contain z-20">`;
                } else {
                    canvasImgHtml = `<div class="absolute inset-0 z-20 flex items-center justify-center text-[9px] text-gray-300 italic">未入力</div>`;
                }

                const feedbackImgHtml = data.feedbackData ? `<img src="${data.feedbackData}" class="absolute inset-0 w-full h-full object-contain z-30">` : '';
                
                div.innerHTML = `
                    <div class="absolute inset-0 z-[60] bg-transparent"></div>
                    <div class="relative z-[70] bg-white bg-opacity-90 px-1 py-0.5 mb-0.5 border-b border-gray-50">
                         <p class="text-[10px] font-bold truncate text-blue-900">${data.name}</p>
                    </div>
                    <div class="relative aspect-[4/3] bg-white pointer-events-none overflow-hidden w-full">
                        ${bgImgHtml}
                        ${canvasImgHtml}
                        ${feedbackImgHtml}
                    </div>
                `;
                div.addEventListener('click', () => window.openPreviewModal(data.uid, data.name));
                grid.appendChild(div);
            });
        }

        window.updateUI = () => {
            if (!window.state) return;
            document.getElementById('task-display').textContent = window.state.currentTask;
            document.getElementById('role-label').textContent = window.state.role === 'teacher' ? "先生" : "児童";
            document.getElementById('name-label').textContent = window.state.userName + " さん";
            document.getElementById('room-info').textContent = "クラス: " + (window.state.roomName || "未設定");
            
            const studentView = document.getElementById('student-view');
            const teacherView = document.getElementById('teacher-view');
            const submissionsView = document.getElementById('submissions-view');
            const viewSwitch = document.getElementById('view-switch');
            const publicToggleBtn = document.getElementById('public-toggle-btn');
            
            if (window.state.role === 'teacher') {
                teacherView.classList.remove('hidden');
                studentView.classList.add('hidden');
                submissionsView.classList.remove('hidden');
                viewSwitch.classList.add('hidden');
                publicToggleBtn.classList.remove('hidden');
                publicToggleBtn.textContent = window.state.isPublic ? "全員公開中" : "回答を全員公開";
                publicToggleBtn.className = window.state.isPublic ? "px-4 py-1.5 bg-green-600 text-white rounded-full text-[10px] font-bold" : "px-4 py-1.5 bg-blue-700 text-white rounded-full text-[10px] font-bold";
            } else {
                teacherView.classList.add('hidden');
                publicToggleBtn.classList.add('hidden');
                if (window.state.isPublic) viewSwitch.classList.remove('hidden');
                else { viewSwitch.classList.add('hidden'); window.state.viewMode = 'mine'; }
                if (window.state.viewMode === 'mine') { studentView.classList.remove('hidden'); submissionsView.classList.add('hidden'); } 
                else { studentView.classList.add('hidden'); submissionsView.classList.remove('hidden'); }
            }
            window.updateToolStyles();
        };

        window.updateToolStyles = () => {
            const btns = document.querySelectorAll('.tool-btn');
            btns.forEach(btn => {
                const color = btn.getAttribute('data-color');
                const type = btn.getAttribute('data-type');
                
                btn.classList.remove('ring-4', 'ring-blue-400', 'ring-offset-2');
                
                if (type === 'eraser' && window.state.isEraser) {
                    btn.classList.add('ring-4', 'ring-blue-400', 'ring-offset-2');
                } else if (type === 'color' && !window.state.isEraser && window.state.brushColor === color) {
                    btn.classList.add('ring-4', 'ring-blue-400', 'ring-offset-2');
                }
            });
        };

        function checkUrlParams() {
            const p = new URLSearchParams(window.location.search);
            window.state.role = p.get('role') || 'student';
            const roomParam = p.get('room');
            if (roomParam) {
                window.state.roomName = normalizeId(roomParam);
                localStorage.setItem('school_note_room_name', window.state.roomName);
            } else {
                window.state.roomName = normalizeId(localStorage.getItem('school_note_room_name')) || '';
            }
            const nameParam = p.get('name');
            if (nameParam) {
                window.state.userName = nameParam;
                localStorage.setItem('school_note_user_name', window.state.userName);
            } else {
                window.state.userName = localStorage.getItem('school_note_user_name') || '';
            }
        }

        window.setPenColor = (c) => {
            window.state.brushColor = c;
            window.state.isEraser = false;
            window.updateToolStyles();
        };

        window.setEraser = () => {
            window.state.isEraser = true;
            window.updateToolStyles();
        };

        window.changeName = () => {
            const newName = prompt("新しいなまえを入力してください", window.state.userName);
            if (newName) {
                window.state.userName = newName;
                localStorage.setItem('school_note_user_name', window.state.userName);
                window.updateUI();
                window.syncCanvas();
            }
        };
        window.changeRoom = () => {
            const newRoom = prompt("新しいクラス名（合言葉）を入力してください", window.state.roomName);
            if (newRoom) {
                window.state.roomName = normalizeId(newRoom);
                localStorage.setItem('school_note_room_name', window.state.roomName);
                window.location.reload();
            }
        };
    </script>
    <style>
        * { -webkit-tap-highlight-color: transparent; box-sizing: border-box; }
        body { touch-action: none; -webkit-user-select: none; user-select: none; overflow: hidden; position: fixed; width: 100%; height: 100%; margin: 0; padding: 0; }
        .canvas-container { position: relative; width: 100%; background: white; z-index: 10; touch-action: none; }
        canvas { display: block; touch-action: none; opacity: 1 !important; }
        #feedback-layer { pointer-events: none; z-index: 20; }
        .task-bg, #feedback-task-bg, #feedback-bg { background-color: white; }
        
        .teacher-scroll-menu {
            scrollbar-width: none;
            -ms-overflow-style: none;
        }
        .teacher-scroll-menu::-webkit-scrollbar { display: none; }

        #feedback-task-bg { z-index: 100; }
        #feedback-bg { z-index: 101; }
        #feedback-canvas { z-index: 102; }

        .tool-btn { transition: all 0.2s; }
    </style>
</head>
<body class="bg-gray-100 flex flex-col font-sans text-gray-900 overflow-hidden">
    <nav class="bg-blue-900 text-white p-3 flex justify-between items-center shadow-lg flex-shrink-0 z-50">
        <div class="flex flex-col">
            <h1 class="font-bold text-sm flex items-center gap-2">
                EdTech Canvas Pro 
                <span id="role-label" class="text-[10px] bg-blue-600 px-2 py-0.5 rounded-full"></span>
            </h1>
            <span id="room-info" class="text-[9px] opacity-70 cursor-pointer hover:underline" onclick="window.changeRoom()"></span>
        </div>
        <div id="name-label" class="text-xs font-medium cursor-pointer underline underline-offset-4" onclick="window.changeName()"></div>
    </nav>

    <div class="p-2 flex-grow flex flex-col overflow-hidden relative">
        <div id="task-container" class="bg-white p-2 rounded-lg shadow-sm mb-2 border-l-8 border-blue-600 flex justify-between items-center flex-shrink-0">
            <h2 id="task-display" class="text-xs font-black truncate text-gray-800 max-w-[70%]"></h2>
            <button id="public-toggle-btn" onclick="window.togglePublic()" class="hidden shadow-sm"></button>
        </div>

        <div id="view-switch" class="hidden flex gap-2 mb-2 px-1 flex-shrink-0">
            <button onclick="window.switchView('mine')" class="flex-1 py-3 rounded-xl font-bold bg-blue-600 text-white shadow-lg text-sm transition-all active:scale-95">自分のノート</button>
            <button onclick="window.switchView('others')" class="flex-1 py-3 rounded-xl font-bold bg-gray-300 text-gray-600 text-sm transition-all active:scale-95">みんなのノート</button>
        </div>
        
        <div id="student-view" class="flex-grow flex flex-col gap-1 overflow-hidden">
            <div id="student-tools" class="bg-white p-2 rounded-t-xl shadow-md flex gap-4 items-center flex-shrink-0 z-30 border-b">
                <button onclick="window.setPenColor('#000000')" data-color="#000000" data-type="color" class="tool-btn w-9 h-9 rounded-full bg-black border-2 border-gray-100 shadow-sm active:scale-110"></button>
                <button onclick="window.setPenColor('#ff4444')" data-color="#ff4444" data-type="color" class="tool-btn w-9 h-9 rounded-full bg-red-500 border-2 border-gray-100 shadow-sm active:scale-110"></button>
                <button onclick="window.setPenColor('#4444ff')" data-color="#4444ff" data-type="color" class="tool-btn w-9 h-9 rounded-full bg-blue-500 border-2 border-gray-100 shadow-sm active:scale-110"></button>
                <!-- 消しゴム -->
                <button onclick="window.setEraser()" data-type="eraser" class="tool-btn w-9 h-9 rounded-full bg-white border-2 border-gray-300 shadow-sm flex items-center justify-center active:scale-110">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-gray-600"><path d="m7 21-4.3-4.3c-1-1-1-2.5 0-3.4l9.9-9.9c1-1 2.5-1 3.4 0l4.4 4.4c1 1 1 2.5 0 3.4L10.5 21z"/><path d="m15 5 4 4"/></svg>
                </button>
                <button onclick="window.clearCanvas('drawing-canvas')" class="ml-auto text-[11px] text-red-500 font-bold px-3 py-1 bg-red-50 rounded-full border border-red-100">全部消す</button>
            </div>
            <div class="canvas-container flex-grow border-x-2 border-b-2 border-gray-200 rounded-b-xl shadow-sm relative overflow-hidden bg-white">
                <div class="task-bg absolute inset-0 pointer-events-none"></div>
                <canvas id="drawing-canvas" class="absolute inset-0 z-10"></canvas>
                <canvas id="feedback-layer" class="absolute inset-0 z-20"></canvas>
            </div>
        </div>

        <div id="teacher-view" class="hidden bg-white p-2 rounded-xl border-2 border-blue-400 flex flex-col gap-2 mb-2 flex-shrink-0 shadow-md">
            <div class="flex gap-2 overflow-x-auto teacher-scroll-menu py-1">
                <button onclick="window.openTaskCreateModal()" class="flex-shrink-0 bg-blue-700 text-white px-4 py-2 rounded-full text-[10px] font-bold shadow-md active:scale-95">＋ 課題作成</button>
                <button onclick="window.resetAllCanvases()" class="flex-shrink-0 bg-red-100 text-red-700 border border-red-200 px-4 py-2 rounded-full text-[10px] font-bold active:scale-95">全員の回答をリセット</button>
            </div>
            <div class="text-[9px] text-blue-900 bg-blue-50 p-1.5 rounded border border-blue-100">
                名前をタップして添削・個別削除が可能です。
            </div>
        </div>

        <div id="submissions-view" class="hidden flex-grow flex flex-col overflow-hidden">
            <div id="submissions-grid" class="grid grid-cols-2 sm:grid-cols-4 md:grid-cols-5 lg:grid-cols-7 gap-2 overflow-y-auto pb-20 p-1"></div>
        </div>
    </div>

    <!-- 課題作成モーダル -->
    <div id="task-create-modal" class="fixed inset-0 bg-black bg-opacity-90 z-[100] hidden flex flex-col p-2 md:p-6">
        <div class="bg-white rounded-2xl flex flex-col h-full overflow-hidden shadow-2xl">
            <div class="bg-blue-800 text-white p-4 flex justify-between items-center">
                <h3 class="font-bold text-base">課題の作成・配信</h3>
                <button onclick="window.closeTaskCreateModal()" class="text-xs bg-gray-700 hover:bg-gray-600 px-4 py-2 rounded-full">戻る</button>
            </div>
            <div class="p-3 border-b bg-gray-50 flex flex-wrap gap-4 items-center">
                <input type="text" id="task-title-input" placeholder="課題名（例：漢字練習）" class="border-2 border-blue-100 p-2 rounded-lg text-sm flex-grow outline-none focus:border-blue-400">
                <label class="bg-blue-600 text-white px-5 py-2 rounded-full cursor-pointer text-xs font-bold shadow">
                    画像を貼る
                    <input type="file" accept="image/*" class="hidden" onchange="window.handleTaskImageUpload(event)">
                </label>
            </div>
            <div class="bg-white p-3 flex gap-5 items-center border-b">
                <button onclick="window.setPenColor('#000000')" data-color="#000000" data-type="color" class="tool-btn w-8 h-8 rounded-full bg-black border-2 border-gray-200"></button>
                <button onclick="window.setPenColor('#ff0000')" data-color="#ff0000" data-type="color" class="tool-btn w-8 h-8 rounded-full bg-red-600 border-2 border-gray-200"></button>
                <button onclick="window.setPenColor('#0000ff')" data-color="#0000ff" data-type="color" class="tool-btn w-8 h-8 rounded-full bg-blue-600 border-2 border-gray-200"></button>
                <!-- 課題作成用消しゴム -->
                <button onclick="window.setEraser()" data-type="eraser" class="tool-btn w-8 h-8 rounded-full bg-white border-2 border-gray-300 flex items-center justify-center">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-gray-600"><path d="m7 21-4.3-4.3c-1-1-1-2.5 0-3.4l9.9-9.9c1-1 2.5-1 3.4 0l4.4 4.4c1 1 1 2.5 0 3.4L10.5 21z"/><path d="m15 5 4 4"/></svg>
                </button>
                <button onclick="window.clearCanvas('task-create-canvas')" class="ml-auto text-[10px] bg-red-50 text-red-600 border border-red-200 px-3 py-1.5 rounded-full font-bold">リセット</button>
            </div>
            <div class="canvas-container flex-grow relative bg-white overflow-hidden">
                <div id="task-image-overlay" class="absolute inset-0 z-10 pointer-events-none"></div>
                <canvas id="task-create-canvas" class="absolute inset-0 z-20"></canvas>
            </div>
            <div class="p-4 bg-gray-100 text-center border-t">
                <button onclick="window.finalizeAndDistribute()" class="bg-green-600 hover:bg-green-700 text-white px-12 py-4 rounded-full font-black shadow-xl text-sm transition-all active:scale-95">
                    クラス全員に配信する
                </button>
            </div>
        </div>
    </div>

    <!-- 添削・個別削除モーダル -->
    <div id="feedback-modal" class="fixed inset-0 bg-black bg-opacity-95 z-[100] hidden flex flex-col p-2">
        <div class="flex justify-between items-center text-white mb-3 px-4 pt-2">
            <h3 class="font-bold text-sm">ノートを添削中</h3>
            <div class="flex gap-4 items-center">
                <button onclick="window.setPenColor('#ff0000')" data-color="#ff0000" data-type="color" class="tool-btn w-10 h-10 rounded-full bg-red-600 border-4 border-white shadow-lg"></button>
                <!-- 添削用消しゴム -->
                <button onclick="window.setEraser()" data-type="eraser" class="tool-btn w-10 h-10 rounded-full bg-white border-4 border-gray-300 shadow-lg flex items-center justify-center">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-gray-700"><path d="m7 21-4.3-4.3c-1-1-1-2.5 0-3.4l9.9-9.9c1-1 2.5-1 3.4 0l4.4 4.4c1 1 1 2.5 0 3.4L10.5 21z"/><path d="m15 5 4 4"/></svg>
                </button>
                <button onclick="window.resetStudentCanvas()" class="bg-red-600 px-4 py-2 rounded-full text-[10px] font-bold shadow-md">この回答をリセット</button>
                <button onclick="window.closeFeedbackModal()" class="bg-blue-600 px-6 py-2 rounded-full text-[10px] font-bold shadow-md">戻る</button>
            </div>
        </div>
        <div class="canvas-container flex-grow relative bg-white rounded-2xl overflow-hidden shadow-2xl">
            <div id="feedback-task-bg" class="absolute inset-0 bg-contain bg-center bg-no-repeat pointer-events-none opacity-100"></div>
            <div id="feedback-bg" class="absolute inset-0 bg-contain bg-center bg-no-repeat pointer-events-none mix-blend-multiply opacity-90"></div>
            <canvas id="feedback-canvas" class="absolute inset-0"></canvas>
        </div>
    </div>
</body>
</html>
