<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>EdTech Canvas Pro</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, setDoc, onSnapshot, collection, getDoc, writeBatch, getDocs } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        const firebaseConfig = {
            apiKey: "AIzaSyD2UPzm5FauzRDMUi_iv-5PQDG391xL_Eo",
            authDomain: "minnnano-no-to.firebaseapp.com",
            projectId: "minnnano-no-to",
            storageBucket: "minnnano-no-to.firebasestorage.app",
            messagingSenderId: "589337230554",
            appId: "1:589337230554:web:6c564cb5bbe08573ceb9e3"
        };

        // Initialize state
        window.state = {
            user: null,
            role: 'student',
            roomName: '', 
            viewMode: 'mine', 
            userName: '',
            currentTask: "課題を待っています...",
            isPublic: false,
            isDrawing: false,
            brushColor: '#000000',
            brushSize: 4,
            eraserSize: 20,
            isEraser: false,
            bgImage: null,
            editingStudentId: null,
            isTaskCreating: false,
            floatingImages: [],
            selectedImageIdx: -1,
            isResizing: false,
            isDraggingImage: false
        };

        let app, auth, db;
        try {
            app = initializeApp(firebaseConfig);
            auth = getAuth(app);
            db = getFirestore(app);
            window.db = db;
        } catch (e) {
            console.error("Firebase initialization failed", e);
        }

        const appId = typeof __app_id !== 'undefined' ? __app_id : 'edtech-canvas-pro';
        window.appId = appId;

        window.getElements = () => {
            window.canvas = document.getElementById('drawing-canvas');
            window.feedbackCanvas = document.getElementById('feedback-canvas');
            window.taskCreateCanvas = document.getElementById('task-create-canvas');
            window.eraserCursor = document.getElementById('eraser-cursor');
        };

        function normalizeId(str) {
            if (!str) return "";
            return str.replace(/[Ａ-Ｚａ-ｚ０-９]/g, (s) => {
                return String.fromCharCode(s.charCodeAt(0) - 0xFEE0);
            }).toLowerCase().replace(/\s+/g, '');
        }

        window.onload = async () => {
            window.getElements();
            checkUrlParams(); 
            
            if (!window.state.roomName) {
                const savedRoom = localStorage.getItem('school_note_room_name');
                let room = prompt("クラス名（合言葉）を入力してください", savedRoom || "");
                if (!room) room = "default";
                window.state.roomName = normalizeId(room);
                localStorage.setItem('school_note_room_name', window.state.roomName);
            }

            if (!window.state.userName) {
                const savedName = localStorage.getItem('school_note_user_name');
                const name = prompt("あなたのなまえを入力してください", savedName || "");
                window.state.userName = name || (window.state.role === 'teacher' ? "先生" : "ゲスト") + "_" + Math.floor(Math.random() * 1000);
                localStorage.setItem('school_note_user_name', window.state.userName);
            }

            setTimeout(window.setupMainCanvas, 100);
            window.addEventListener('resize', window.setupMainCanvas);
            
            window.updateUI();
            setupEventListeners(window.canvas); 
            setupEventListeners(window.feedbackCanvas);
            setupTaskCreateListeners(window.taskCreateCanvas);

            document.addEventListener('paste', handlePaste);

            if (!auth) return;

            const initAuth = async () => {
                try {
                    if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                        try {
                            await signInWithCustomToken(auth, __initial_auth_token);
                        } catch (tokenError) {
                            await signInAnonymously(auth);
                        }
                    } else {
                        await signInAnonymously(auth);
                    }
                } catch (error) {}
            };

            onAuthStateChanged(auth, (user) => {
                if (user) {
                    window.state.user = user;
                    initSync();
                    window.updateUI();
                    syncCanvas();
                }
            });

            await initAuth();
        };

        function getRoomDoc(subCol, docId) {
            return doc(window.db, 'artifacts', window.appId, 'public', 'data', `room_${window.state.roomName}_${subCol}`, docId);
        }
        function getRoomCollection(subCol) {
            return collection(window.db, 'artifacts', window.appId, 'public', 'data', `room_${window.state.roomName}_${subCol}`);
        }

        function initSync() {
            if (!window.db || !window.state.roomName || !window.state.user) return;
            const settingsRef = getRoomDoc('settings', 'current');
            onSnapshot(settingsRef, (snap) => {
                if (snap.exists()) {
                    const data = snap.data();
                    window.state.currentTask = data.taskTitle || "課題を待っています...";
                    window.state.bgImage = data.bgImage || null;
                    window.state.isPublic = data.isPublic || false;
                    if (window.state.role === 'student' && !window.state.isPublic) window.state.viewMode = 'mine';
                    window.applyBg();
                    window.updateUI();
                }
            });

            if (window.state.role === 'student') {
                onSnapshot(getRoomDoc('submissions', window.state.user.uid), (snap) => {
                    const feedbackLayer = document.getElementById('feedback-layer');
                    if (snap.exists()) {
                        const data = snap.data();
                        if (data.feedbackData) renderFeedback(data.feedbackData);
                        else if (feedbackLayer) feedbackLayer.getContext('2d').clearRect(0, 0, feedbackLayer.width, feedbackLayer.height);
                        if (data.canvasData === null) {
                            window.canvas.getContext('2d').clearRect(0, 0, window.canvas.width, window.canvas.height);
                        }
                    }
                });
            }

            onSnapshot(getRoomCollection('submissions'), (snap) => {
                const list = [];
                snap.forEach(doc => {
                    const d = doc.data();
                    list.push(d);
                });
                renderSubmissionsGrid(list);
            });
        }

        function renderFeedback(dataUrl) {
            if (!dataUrl) return;
            const img = new Image();
            img.onload = () => {
                const feedbackLayer = document.getElementById('feedback-layer');
                if (feedbackLayer) {
                    const fctxL = feedbackLayer.getContext('2d');
                    fctxL.clearRect(0, 0, feedbackLayer.width, feedbackLayer.height);
                    fctxL.drawImage(img, 0, 0, feedbackLayer.width, feedbackLayer.height);
                }
            };
            img.src = dataUrl;
        }

        async function syncCanvas() {
            if (!window.state.user || !window.db || !window.state.roomName) return;
            if (window.state.role === 'student') {
                const dataUrl = window.canvas.toDataURL('image/webp', 0.5);
                await setDoc(getRoomDoc('submissions', window.state.user.uid), {
                    uid: window.state.user.uid,
                    name: window.state.userName,
                    canvasData: dataUrl,
                    lastUpdate: Date.now()
                }, { merge: true });
            }
            if (window.state.role === 'teacher' && window.state.editingStudentId) {
                const feedbackDataUrl = window.feedbackCanvas.toDataURL('image/webp', 0.5);
                await setDoc(getRoomDoc('submissions', window.state.editingStudentId), {
                    feedbackData: feedbackDataUrl,
                    lastUpdate: Date.now()
                }, { merge: true });
            }
        }
        window.syncCanvas = syncCanvas;

        window.setupMainCanvas = () => {
            if (!window.canvas) window.getElements();
            const container = window.canvas.parentElement;
            if (!container) return;
            const navH = document.querySelector('nav').offsetHeight;
            const taskH = document.getElementById('task-container').offsetHeight;
            const switchH = (window.state.role === 'student' && window.state.isPublic) ? document.getElementById('view-switch').offsetHeight : 0;
            const toolH = document.getElementById('student-tools')?.offsetHeight || 0;
            const teacherToolH = (window.state.role === 'teacher' && !document.getElementById('teacher-view').classList.contains('hidden')) ? document.getElementById('teacher-view').offsetHeight : 0;
            const availableH = window.innerHeight - navH - taskH - switchH - toolH - teacherToolH - 40;
            const rect = container.getBoundingClientRect();
            
            const temp = document.createElement('canvas');
            temp.width = window.canvas.width; temp.height = window.canvas.height;
            if (window.canvas.width > 0) temp.getContext('2d').drawImage(window.canvas, 0, 0);
            
            window.canvas.width = rect.width;
            window.canvas.height = Math.max(300, availableH);
            const feedbackLayer = document.getElementById('feedback-layer');
            feedbackLayer.width = window.canvas.width;
            feedbackLayer.height = window.canvas.height;
            
            if (temp.width > 0) window.canvas.getContext('2d').drawImage(temp, 0, 0, window.canvas.width, window.canvas.height);
            window.applyBg();
        };

        function setupEventListeners(targetCanvas) {
            const updateCursor = (e) => {
                if (!window.state.isEraser) {
                    window.eraserCursor.style.display = 'none';
                    return;
                }
                const rect = targetCanvas.getBoundingClientRect();
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                
                // キャンバス外に出たかチェック
                if (clientX < rect.left || clientX > rect.right || clientY < rect.top || clientY > rect.bottom) {
                    window.eraserCursor.style.display = 'none';
                    return;
                }

                window.eraserCursor.style.display = 'block';
                window.eraserCursor.style.width = window.state.eraserSize + 'px';
                window.eraserCursor.style.height = window.state.eraserSize + 'px';
                window.eraserCursor.style.left = (clientX - window.state.eraserSize / 2) + 'px';
                window.eraserCursor.style.top = (clientY - window.state.eraserSize / 2) + 'px';
            };

            const getPos = (e) => {
                const rect = targetCanvas.getBoundingClientRect();
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                return { 
                    x: (clientX - rect.left) * (targetCanvas.width / rect.width), 
                    y: (clientY - rect.top) * (targetCanvas.height / rect.height)
                };
            };
            const start = (e) => {
                if (window.state.role === 'student' && window.state.viewMode === 'others') return;
                window.state.isDrawing = true;
                const tctx = targetCanvas.getContext('2d');
                const pos = getPos(e);
                tctx.beginPath();
                tctx.moveTo(pos.x, pos.y);
                updateCursor(e);
            };
            const move = (e) => {
                updateCursor(e);
                if (!window.state.isDrawing) return;
                const tctx = targetCanvas.getContext('2d');
                const pos = getPos(e);
                
                if (window.state.isEraser) {
                    tctx.globalCompositeOperation = 'destination-out';
                    tctx.lineWidth = window.state.eraserSize;
                } else {
                    tctx.globalCompositeOperation = 'source-over';
                    tctx.strokeStyle = window.state.brushColor;
                    tctx.lineWidth = window.state.brushSize;
                }
                
                tctx.lineJoin = 'round';
                tctx.lineCap = 'round';
                tctx.lineTo(pos.x, pos.y);
                tctx.stroke();
            };
            const stop = () => {
                if (window.state.isDrawing) {
                    window.state.isDrawing = false;
                    window.syncCanvas();
                }
                window.eraserCursor.style.display = 'none';
            };

            targetCanvas.addEventListener('mousedown', start);
            targetCanvas.addEventListener('mousemove', move);
            targetCanvas.addEventListener('mouseenter', (e) => { if(window.state.isEraser) window.eraserCursor.style.display = 'block'; });
            targetCanvas.addEventListener('mouseleave', () => { window.eraserCursor.style.display = 'none'; });
            window.addEventListener('mouseup', stop);
            targetCanvas.addEventListener('touchstart', (e) => { if (window.state.role === 'student' && window.state.viewMode === 'others') return; start(e); }, {passive: false});
            targetCanvas.addEventListener('touchmove', (e) => { if (window.state.role === 'student' && window.state.viewMode === 'others') return; e.preventDefault(); move(e); }, {passive: false});
            targetCanvas.addEventListener('touchend', stop);
        }

        function handlePaste(e) {
            if (!window.state.isTaskCreating) return;
            const items = (e.clipboardData || e.originalEvent.clipboardData).items;
            for (let item of items) {
                if (item.type.indexOf("image") !== -1) {
                    const blob = item.getAsFile();
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        const img = new Image();
                        img.onload = () => {
                            window.state.floatingImages.push({
                                img: img, x: 50, y: 50,
                                w: img.width > 400 ? 400 : img.width,
                                h: img.width > 400 ? (img.height * (400 / img.width)) : img.height
                            });
                            window.drawTaskCreateCanvas();
                        };
                        img.src = event.target.result;
                    };
                    reader.readAsDataURL(blob);
                }
            }
        }

        function setupTaskCreateListeners(targetCanvas) {
            let lastX, lastY;

            const updateCursor = (e) => {
                if (!window.state.isEraser) {
                    window.eraserCursor.style.display = 'none';
                    return;
                }
                const rect = targetCanvas.getBoundingClientRect();
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                if (clientX < rect.left || clientX > rect.right || clientY < rect.top || clientY > rect.bottom) {
                    window.eraserCursor.style.display = 'none';
                    return;
                }
                window.eraserCursor.style.display = 'block';
                window.eraserCursor.style.width = window.state.eraserSize + 'px';
                window.eraserCursor.style.height = window.state.eraserSize + 'px';
                window.eraserCursor.style.left = (clientX - window.state.eraserSize / 2) + 'px';
                window.eraserCursor.style.top = (clientY - window.state.eraserSize / 2) + 'px';
            };

            const getPos = (e) => {
                const rect = targetCanvas.getBoundingClientRect();
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                return { 
                    x: (clientX - rect.left) * (targetCanvas.width / rect.width), 
                    y: (clientY - rect.top) * (targetCanvas.height / rect.height)
                };
            };
            const start = (e) => {
                const pos = getPos(e);
                lastX = pos.x; lastY = pos.y;
                window.state.selectedImageIdx = -1;
                window.state.isResizing = false;
                window.state.isDraggingImage = false;
                for (let i = window.state.floatingImages.length - 1; i >= 0; i--) {
                    const img = window.state.floatingImages[i];
                    if (pos.x > img.x + img.w - 40 && pos.x < img.x + img.w + 20 &&
                        pos.y > img.y + img.h - 40 && pos.y < img.y + img.h + 20) {
                        window.state.selectedImageIdx = i; window.state.isResizing = true; break;
                    }
                    if (pos.x > img.x && pos.x < img.x + img.w && pos.y > img.y && pos.y < img.y + img.h) {
                        window.state.selectedImageIdx = i; window.state.isDraggingImage = true; break;
                    }
                }
                if (window.state.selectedImageIdx === -1) {
                    window.state.isDrawing = true;
                    const ctx = targetCanvas.getContext('2d');
                    ctx.beginPath();
                    ctx.moveTo(pos.x, pos.y);
                }
                updateCursor(e);
                window.drawTaskCreateCanvas();
            };
            const move = (e) => {
                updateCursor(e);
                const pos = getPos(e);
                const dx = pos.x - lastX;
                const dy = pos.y - lastY;
                if (window.state.selectedImageIdx !== -1) {
                    const img = window.state.floatingImages[window.state.selectedImageIdx];
                    if (window.state.isResizing) {
                        img.w = Math.max(50, img.w + dx);
                        img.h = Math.max(50, img.h + dy);
                    } else if (window.state.isDraggingImage) {
                        img.x += dx; img.y += dy;
                    }
                    window.drawTaskCreateCanvas();
                } else if (window.state.isDrawing) {
                    const ctx = targetCanvas.getContext('2d');
                    if (window.state.isEraser) {
                        ctx.globalCompositeOperation = 'destination-out';
                        ctx.lineWidth = window.state.eraserSize;
                    } else {
                        ctx.globalCompositeOperation = 'source-over';
                        ctx.strokeStyle = window.state.brushColor;
                        ctx.lineWidth = window.state.brushSize;
                    }
                    ctx.lineJoin = 'round'; ctx.lineCap = 'round';
                    ctx.lineTo(pos.x, pos.y);
                    ctx.stroke();
                }
                lastX = pos.x; lastY = pos.y;
            };
            const stop = () => {
                window.state.isDrawing = false;
                window.state.isResizing = false;
                window.state.isDraggingImage = false;
                window.eraserCursor.style.display = 'none';
            };
            targetCanvas.addEventListener('mousedown', start);
            targetCanvas.addEventListener('mousemove', move);
            targetCanvas.addEventListener('mouseenter', (e) => { if(window.state.isEraser) window.eraserCursor.style.display = 'block'; });
            targetCanvas.addEventListener('mouseleave', () => { window.eraserCursor.style.display = 'none'; });
            window.addEventListener('mouseup', stop);
            targetCanvas.addEventListener('touchstart', start, {passive: false});
            targetCanvas.addEventListener('touchmove', (e) => { e.preventDefault(); move(e); }, {passive: false});
            window.addEventListener('touchend', stop);
        }

        window.drawTaskCreateCanvas = () => {
            const overlay = document.getElementById('task-image-overlay');
            if (!overlay) return;
            overlay.innerHTML = '';
            window.state.floatingImages.forEach((imgData, idx) => {
                const imgWrap = document.createElement('div');
                imgWrap.className = `absolute border-2 ${window.state.selectedImageIdx === idx ? 'border-blue-500 shadow-2xl z-30' : 'border-gray-300 z-20'}`;
                imgWrap.style.left = `${imgData.x}px`; imgWrap.style.top = `${imgData.y}px`;
                imgWrap.style.width = `${imgData.w}px`; imgWrap.style.height = `${imgData.h}px`;
                imgWrap.style.backgroundImage = `url(${imgData.img.src})`;
                imgWrap.style.backgroundSize = '100% 100%';
                imgWrap.style.pointerEvents = 'none'; 
                if (window.state.selectedImageIdx === idx) {
                    const handle = document.createElement('div');
                    handle.className = "absolute right-[-15px] bottom-[-15px] w-8 h-8 bg-blue-600 rounded-full border-2 border-white flex items-center justify-center shadow-lg pointer-events-none";
                    handle.innerHTML = `<svg width="16" height="16" viewBox="0 0 24 24" fill="white"><path d="M21 15v6h-6M9 3H3v6M21 3l-6 6M3 21l6-6"/></svg>`;
                    imgWrap.appendChild(handle);
                    const del = document.createElement('div');
                    del.className = "absolute left-[-15px] top-[-15px] w-8 h-8 bg-red-600 text-white rounded-full flex items-center justify-center text-[14px] font-bold cursor-pointer pointer-events-auto shadow-md";
                    del.textContent = '×';
                    del.onclick = (e) => { e.stopPropagation(); window.state.floatingImages.splice(idx, 1); window.state.selectedImageIdx = -1; window.drawTaskCreateCanvas(); };
                    imgWrap.appendChild(del);
                }
                overlay.appendChild(imgWrap);
            });
        };

        window.openTaskCreateModal = () => {
            window.state.isTaskCreating = true;
            window.state.floatingImages = [];
            window.state.selectedImageIdx = -1;
            window.state.isEraser = false;
            window.state.brushColor = '#000000';
            const modal = document.getElementById('task-create-modal');
            modal.classList.remove('hidden');
            const container = window.taskCreateCanvas.parentElement;
            window.taskCreateCanvas.width = container.offsetWidth;
            window.taskCreateCanvas.height = container.offsetHeight;
            window.taskCreateCanvas.getContext('2d').clearRect(0, 0, window.taskCreateCanvas.width, window.taskCreateCanvas.height);
            document.getElementById('task-title-input').value = "";
            window.drawTaskCreateCanvas();
            window.updateToolStyles();
        };

        window.closeTaskCreateModal = () => {
            window.state.isTaskCreating = false;
            document.getElementById('task-create-modal').classList.add('hidden');
        };

        window.finalizeAndDistribute = async () => {
            const title = document.getElementById('task-title-input').value || "新しい課題";
            const offscreen = document.createElement('canvas');
            offscreen.width = window.taskCreateCanvas.width; offscreen.height = window.taskCreateCanvas.height;
            const octx = offscreen.getContext('2d');
            octx.fillStyle = "#ffffff"; octx.fillRect(0, 0, offscreen.width, offscreen.height);
            for (let imgData of window.state.floatingImages) octx.drawImage(imgData.img, imgData.x, imgData.y, imgData.w, imgData.h);
            octx.drawImage(window.taskCreateCanvas, 0, 0);
            const finalDataUrl = offscreen.toDataURL('image/jpeg', 0.8); 
            if (confirm("この内容をクラス全員に配信しますか？")) {
                await setDoc(getRoomDoc('settings', 'current'), { taskTitle: title, bgImage: finalDataUrl, lastDistribute: Date.now() });
                alert("配信しました！"); window.closeTaskCreateModal();
            }
        };

        window.openPreviewModal = async (uid, name) => {
            window.state.editingStudentId = uid;
            window.state.brushColor = '#ff0000'; window.state.isEraser = false;
            document.getElementById('feedback-modal').classList.remove('hidden');
            const container = window.feedbackCanvas.parentElement;
            window.feedbackCanvas.width = container.offsetWidth; window.feedbackCanvas.height = container.offsetHeight;
            const snap = await getDoc(getRoomDoc('submissions', uid));
            if (snap.exists()) {
                const data = snap.data();
                document.getElementById('feedback-task-bg').style.backgroundImage = window.state.bgImage ? `url(${window.state.bgImage})` : 'none';
                document.getElementById('feedback-bg').style.backgroundImage = data.canvasData ? `url(${data.canvasData})` : 'none';
                const fctx = window.feedbackCanvas.getContext('2d');
                fctx.clearRect(0, 0, window.feedbackCanvas.width, window.feedbackCanvas.height);
                if (data.feedbackData) {
                    const img = new Image();
                    img.onload = () => fctx.drawImage(img, 0, 0, window.feedbackCanvas.width, window.feedbackCanvas.height);
                    img.src = data.feedbackData;
                }
            }
            window.updateToolStyles();
        };

        window.closeFeedbackModal = () => {
            window.state.editingStudentId = null;
            document.getElementById('feedback-modal').classList.add('hidden');
        };

        window.switchView = (mode) => {
            if (mode === 'others' && !window.state.isPublic && window.state.role === 'student') return;
            window.state.viewMode = mode;
            window.updateUI();
            setTimeout(window.setupMainCanvas, 50);
        };

        window.togglePublic = async () => {
            const newVal = !window.state.isPublic;
            await setDoc(getRoomDoc('settings', 'current'), { isPublic: newVal }, { merge: true });
        };

        window.clearCanvas = (id) => {
            if (confirm("すべて消去しますか？")) {
                const target = document.getElementById(id);
                target.getContext('2d').clearRect(0, 0, target.width, target.height);
                if (id === 'task-create-canvas') { window.state.floatingImages = []; window.state.selectedImageIdx = -1; window.drawTaskCreateCanvas(); } 
                else { window.syncCanvas(); }
            }
        };

        window.applyBg = () => {
            document.querySelectorAll('.task-bg').forEach(bg => {
                if (window.state.bgImage) {
                    bg.style.backgroundImage = `url(${window.state.bgImage})`;
                    bg.style.backgroundSize = 'contain'; bg.style.backgroundPosition = 'center'; bg.style.backgroundRepeat = 'no-repeat';
                }
            });
        };

        function renderSubmissionsGrid(list) {
            const grid = document.getElementById('submissions-grid');
            if (!grid) return; grid.innerHTML = '';
            list.sort((a, b) => (a.name || "").localeCompare(b.name || "", 'ja')).forEach(data => {
                const div = document.createElement('div');
                div.className = "bg-white p-1 border border-gray-200 rounded-md shadow-sm cursor-pointer hover:border-blue-400 relative h-auto overflow-hidden transition-all active:scale-95";
                const bgImgHtml = window.state.bgImage ? `<img src="${window.state.bgImage}" class="absolute inset-0 w-full h-full object-contain z-10">` : '';
                const canvasImgHtml = data.canvasData ? `<img src="${data.canvasData}" class="absolute inset-0 w-full h-full object-contain z-20">` : `<div class="absolute inset-0 z-20 flex items-center justify-center text-[9px] text-gray-300 italic">未入力</div>`;
                const feedbackImgHtml = data.feedbackData ? `<img src="${data.feedbackData}" class="absolute inset-0 w-full h-full object-contain z-30">` : '';
                div.innerHTML = `<div class="absolute inset-0 z-[60] bg-transparent"></div><div class="relative z-[70] bg-white bg-opacity-90 px-1 py-0.5 border-b text-[10px] font-bold truncate text-blue-900">${data.name}</div><div class="relative aspect-[4/3] bg-white pointer-events-none overflow-hidden">${bgImgHtml}${canvasImgHtml}${feedbackImgHtml}</div>`;
                div.onclick = () => window.openPreviewModal(data.uid, data.name);
                grid.appendChild(div);
            });
        }

        window.updateUI = () => {
            if (!window.state) return;
            document.getElementById('task-display').textContent = window.state.currentTask;
            document.getElementById('role-label').textContent = window.state.role === 'teacher' ? "先生" : "児童";
            document.getElementById('name-label').textContent = window.state.userName + " さん";
            document.getElementById('room-info').textContent = "クラス: " + (window.state.roomName || "未設定");
            if (window.state.role === 'teacher') {
                document.getElementById('teacher-view').classList.remove('hidden');
                document.getElementById('student-view').classList.add('hidden');
                document.getElementById('submissions-view').classList.remove('hidden');
                document.getElementById('view-switch').classList.add('hidden');
                const pBtn = document.getElementById('public-toggle-btn');
                pBtn.classList.remove('hidden'); pBtn.textContent = window.state.isPublic ? "全員公開中" : "回答を全員公開";
                pBtn.className = window.state.isPublic ? "px-4 py-1.5 bg-green-600 text-white rounded-full text-[10px] font-bold" : "px-4 py-1.5 bg-blue-700 text-white rounded-full text-[10px] font-bold";
            } else {
                document.getElementById('teacher-view').classList.add('hidden');
                document.getElementById('public-toggle-btn').classList.add('hidden');
                if (window.state.isPublic) document.getElementById('view-switch').classList.remove('hidden');
                else { document.getElementById('view-switch').classList.add('hidden'); window.state.viewMode = 'mine'; }
                if (window.state.viewMode === 'mine') { document.getElementById('student-view').classList.remove('hidden'); document.getElementById('submissions-view').classList.add('hidden'); } 
                else { document.getElementById('student-view').classList.add('hidden'); document.getElementById('submissions-view').classList.remove('hidden'); }
            }
            window.updateToolStyles();
        };

        window.updateToolStyles = () => {
            const currentSize = window.state.isEraser ? window.state.eraserSize : window.state.brushSize;
            document.querySelectorAll('.tool-btn').forEach(btn => {
                const color = btn.getAttribute('data-color');
                const type = btn.getAttribute('data-type');
                btn.classList.toggle('ring-4', (type === 'eraser' && window.state.isEraser) || (type === 'color' && !window.state.isEraser && window.state.brushColor === color));
                btn.classList.toggle('ring-blue-400', btn.classList.contains('ring-4'));
            });
            document.querySelectorAll('.brush-slider').forEach(s => s.value = currentSize);
            document.querySelectorAll('.brush-size-preview').forEach(p => {
                p.style.width = p.style.height = `${currentSize}px`;
                p.style.backgroundColor = window.state.isEraser ? '#cbd5e1' : window.state.brushColor;
            });
        };

        window.setPenColor = (c) => { window.state.brushColor = c; window.state.isEraser = false; window.updateToolStyles(); };
        window.setEraser = () => { window.state.isEraser = true; window.updateToolStyles(); };
        window.updateBrushSize = (val) => {
            if (window.state.isEraser) window.state.eraserSize = parseInt(val);
            else window.state.brushSize = parseInt(val);
            window.updateToolStyles();
        };

        function checkUrlParams() {
            const p = new URLSearchParams(window.location.search);
            window.state.role = p.get('role') || 'student';
            window.state.roomName = normalizeId(p.get('room') || localStorage.getItem('school_note_room_name')) || '';
            window.state.userName = p.get('name') || localStorage.getItem('school_note_user_name') || '';
        }

        window.handleTaskImageUpload = (event) => {
            const file = event.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (e) => {
                const img = new Image();
                img.onload = () => {
                    window.state.floatingImages.push({
                        img: img, x: 50, y: 50,
                        w: img.width > 300 ? 300 : img.width,
                        h: img.width > 300 ? (img.height * (300 / img.width)) : img.height
                    });
                    window.drawTaskCreateCanvas();
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        };
    </script>
    <style>
        * { -webkit-tap-highlight-color: transparent; box-sizing: border-box; }
        body { touch-action: none; -webkit-user-select: none; user-select: none; overflow: hidden; position: fixed; width: 100%; height: 100%; margin: 0; padding: 0; }
        .canvas-container { position: relative; width: 100%; background: white; touch-action: none; }
        canvas { display: block; touch-action: none; }
        #feedback-layer { pointer-events: none; z-index: 20; }
        .brush-slider { -webkit-appearance: none; height: 6px; background: #e2e8f0; border-radius: 5px; outline: none; }
        .brush-slider::-webkit-slider-thumb { -webkit-appearance: none; width: 18px; height: 18px; background: #2563eb; border-radius: 50%; cursor: pointer; border: 2px solid white; }
        
        /* 消しゴムプレビュー用 */
        #eraser-cursor {
            position: fixed;
            pointer-events: none;
            border: 1.5px solid #2563eb;
            background: rgba(37, 99, 235, 0.1);
            border-radius: 50%;
            z-index: 9999;
            display: none;
        }
    </style>
</head>
<body class="bg-gray-100 flex flex-col font-sans overflow-hidden">
    <!-- 消しゴム範囲インジケーター -->
    <div id="eraser-cursor"></div>

    <nav class="bg-blue-900 text-white p-3 flex justify-between items-center shadow-lg flex-shrink-0 z-50">
        <div class="flex flex-col">
            <h1 class="font-bold text-sm">EdTech Canvas Pro <span id="role-label" class="text-[10px] bg-blue-600 px-2 py-0.5 rounded-full ml-1"></span></h1>
            <span id="room-info" class="text-[9px] opacity-70"></span>
        </div>
        <div id="name-label" class="text-xs font-medium"></div>
    </nav>

    <div class="p-2 flex-grow flex flex-col overflow-hidden">
        <div id="task-container" class="bg-white p-2 rounded-lg shadow-sm mb-2 border-l-8 border-blue-600 flex justify-between items-center flex-shrink-0">
            <h2 id="task-display" class="text-xs font-black truncate text-gray-800 max-w-[70%]"></h2>
            <button id="public-toggle-btn" onclick="window.togglePublic()" class="hidden"></button>
        </div>

        <div id="view-switch" class="hidden flex gap-2 mb-2 flex-shrink-0">
            <button onclick="window.switchView('mine')" class="flex-1 py-3 rounded-xl font-bold bg-blue-600 text-white shadow-lg text-sm">自分のノート</button>
            <button onclick="window.switchView('others')" class="flex-1 py-3 rounded-xl font-bold bg-gray-300 text-gray-600 text-sm">みんなのノート</button>
        </div>
        
        <!-- 児童メイン画面 -->
        <div id="student-view" class="flex-grow flex flex-col gap-1 overflow-hidden">
            <div id="student-tools" class="bg-white p-2 rounded-t-xl shadow-md flex flex-wrap gap-3 items-center flex-shrink-0 border-b">
                <div class="flex gap-2">
                    <button onclick="window.setPenColor('#000000')" data-color="#000000" data-type="color" class="tool-btn w-9 h-9 rounded-full bg-black border-2 border-gray-100 shadow-sm"></button>
                    <button onclick="window.setPenColor('#ff4444')" data-color="#ff4444" data-type="color" class="tool-btn w-9 h-9 rounded-full bg-red-500 border-2 border-gray-100 shadow-sm"></button>
                    <button onclick="window.setPenColor('#4444ff')" data-color="#4444ff" data-type="color" class="tool-btn w-9 h-9 rounded-full bg-blue-500 border-2 border-gray-100 shadow-sm"></button>
                    <button onclick="window.setEraser()" data-type="eraser" class="tool-btn w-9 h-9 rounded-full bg-white border-2 border-gray-300 shadow-sm flex items-center justify-center">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="m7 21-4.3-4.3c-1-1-1-2.5 0-3.4l9.9-9.9c1-1 2.5-1 3.4 0l4.4 4.4c1 1 1 2.5 0 3.4L10.5 21z"/><path d="m15 5 4 4"/></svg>
                    </button>
                </div>
                <div class="flex items-center gap-3 bg-gray-50 px-3 py-1 rounded-full border">
                    <span class="text-[9px] font-bold text-gray-500">太さ</span>
                    <input type="range" min="2" max="100" step="1" class="brush-slider w-20 md:w-32" oninput="window.updateBrushSize(this.value)">
                    <div class="brush-size-preview rounded-full transition-all"></div>
                </div>
                <button onclick="window.clearCanvas('drawing-canvas')" class="ml-auto text-[11px] text-red-500 font-bold px-3 py-1 bg-red-50 rounded-full border border-red-100">全部消す</button>
            </div>
            <div class="canvas-container flex-grow border-x-2 border-b-2 border-gray-200 rounded-b-xl relative bg-white overflow-hidden">
                <div class="task-bg absolute inset-0 pointer-events-none"></div>
                <canvas id="drawing-canvas" class="absolute inset-0 z-10"></canvas>
                <canvas id="feedback-layer" class="absolute inset-0 z-20"></canvas>
            </div>
        </div>

        <div id="teacher-view" class="hidden bg-white p-2 rounded-xl border-2 border-blue-400 flex flex-col gap-2 mb-2 flex-shrink-0 shadow-md">
            <div class="flex gap-2 overflow-x-auto py-1">
                <button onclick="window.openTaskCreateModal()" class="flex-shrink-0 bg-blue-700 text-white px-4 py-2 rounded-full text-[10px] font-bold shadow-md">＋ 課題作成</button>
                <button onclick="window.clearCanvas('drawing-canvas')" class="flex-shrink-0 bg-red-100 text-red-700 border border-red-200 px-4 py-2 rounded-full text-[10px] font-bold">全員リセット</button>
            </div>
        </div>

        <div id="submissions-view" class="hidden flex-grow flex flex-col overflow-hidden">
            <div id="submissions-grid" class="grid grid-cols-2 sm:grid-cols-4 md:grid-cols-6 lg:grid-cols-8 gap-2 overflow-y-auto pb-20 p-1"></div>
        </div>
    </div>

    <!-- 課題作成モーダル -->
    <div id="task-create-modal" class="fixed inset-0 bg-black bg-opacity-90 z-[100] hidden flex flex-col p-2">
        <div class="bg-white rounded-2xl flex flex-col h-full overflow-hidden">
            <div class="bg-blue-800 text-white p-3 flex justify-between items-center">
                <h3 class="font-bold text-sm">課題の作成</h3>
                <button onclick="window.closeTaskCreateModal()" class="text-[10px] bg-gray-700 px-3 py-1 rounded-full">戻る</button>
            </div>
            <div class="p-2 border-b flex gap-2 items-center">
                <input type="text" id="task-title-input" placeholder="課題名" class="border-2 p-2 rounded-lg text-sm flex-grow">
                <label class="bg-blue-600 text-white px-4 py-2 rounded-full cursor-pointer text-[10px] font-bold">画像を貼る<input type="file" accept="image/*" class="hidden" onchange="window.handleTaskImageUpload(event)"></label>
            </div>
            <div class="bg-white p-2 flex gap-3 items-center border-b flex-wrap">
                <button onclick="window.setPenColor('#000000')" data-color="#000000" data-type="color" class="tool-btn w-7 h-7 rounded-full bg-black"></button>
                <button onclick="window.setPenColor('#ff0000')" data-color="#ff0000" data-type="color" class="tool-btn w-7 h-7 rounded-full bg-red-600"></button>
                <button onclick="window.setEraser()" data-type="eraser" class="tool-btn w-7 h-7 rounded-full bg-white border-2 border-gray-300 flex items-center justify-center">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="m7 21-4.3-4.3c-1-1-1-2.5 0-3.4l9.9-9.9c1-1 2.5-1 3.4 0l4.4 4.4c1 1 1 2.5 0 3.4L10.5 21z"/><path d="m15 5 4 4"/></svg>
                </button>
                <div class="flex items-center gap-2 bg-gray-50 px-3 py-1 rounded-full border">
                    <input type="range" min="2" max="100" step="1" class="brush-slider w-20" oninput="window.updateBrushSize(this.value)">
                    <div class="brush-size-preview rounded-full"></div>
                </div>
                <button onclick="window.clearCanvas('task-create-canvas')" class="ml-auto text-[10px] text-red-500">リセット</button>
            </div>
            <div class="canvas-container flex-grow relative overflow-hidden">
                <div id="task-image-overlay" class="absolute inset-0 z-10 pointer-events-none"></div>
                <canvas id="task-create-canvas" class="absolute inset-0 z-20"></canvas>
            </div>
            <button onclick="window.finalizeAndDistribute()" class="m-3 bg-green-600 text-white py-3 rounded-full font-black text-sm">全員に配信する</button>
        </div>
    </div>

    <!-- 添削モーダル -->
    <div id="feedback-modal" class="fixed inset-0 bg-black bg-opacity-95 z-[100] hidden flex flex-col p-2">
        <div class="flex flex-wrap gap-3 items-center text-white mb-2 p-2">
            <h3 class="font-bold text-xs mr-auto">添削中</h3>
            <button onclick="window.setPenColor('#ff0000')" data-color="#ff0000" data-type="color" class="tool-btn w-8 h-8 rounded-full bg-red-600 border-2 border-white"></button>
            <button onclick="window.setEraser()" data-type="eraser" class="tool-btn w-8 h-8 rounded-full bg-white border-2 border-gray-300 flex items-center justify-center">
                <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" class="text-gray-800"><path d="m7 21-4.3-4.3c-1-1-1-2.5 0-3.4l9.9-9.9c1-1 2.5-1 3.4 0l4.4 4.4c1 1 1 2.5 0 3.4L10.5 21z"/><path d="m15 5 4 4"/></svg>
            </button>
            <div class="flex items-center gap-2 bg-gray-800 px-3 py-1 rounded-full border border-gray-600">
                <input type="range" min="2" max="100" step="1" class="brush-slider w-20" oninput="window.updateBrushSize(this.value)">
                <div class="brush-size-preview rounded-full"></div>
            </div>
            <button onclick="window.closeFeedbackModal()" class="bg-blue-600 px-4 py-2 rounded-full text-[10px] font-bold">戻る</button>
        </div>
        <div class="canvas-container flex-grow relative bg-white rounded-xl overflow-hidden">
            <div id="feedback-task-bg" class="absolute inset-0 bg-contain bg-center bg-no-repeat pointer-events-none"></div>
            <div id="feedback-bg" class="absolute inset-0 bg-contain bg-center bg-no-repeat pointer-events-none mix-blend-multiply opacity-80"></div>
            <canvas id="feedback-canvas" class="absolute inset-0"></canvas>
        </div>
    </div>
</body>
</html>
